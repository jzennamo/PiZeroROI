////////////////////////////////////////////////////////////////////////
// Class:       PiZeroFilter
// Module Type: filter
// File:        PiZeroFilter_module.cc
//
// Generated at Tue Mar  1 14:26:33 2016 by Matthew Toups using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "art/Framework/Services/Optional/TFileService.h"

#include "PiZeroROI/PiZeroROI.hh"
#include "RecoBase/PFParticle.h"
#include "RecoBase/Vertex.h"
#include "RecoBase/Track.h"
#include "RecoBase/Cluster.h"

class PiZeroFilter;

class PiZeroFilter : public art::EDFilter {
public:
  explicit PiZeroFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PiZeroFilter(PiZeroFilter const &) = delete;
  PiZeroFilter(PiZeroFilter &&) = delete;
  PiZeroFilter & operator = (PiZeroFilter const &) = delete;
  PiZeroFilter & operator = (PiZeroFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  // Declare member data here.
  std::string fPFPModuleLabel;
  std::string fVertexModuleLabel;
  std::string fClusterModuleLabel;
  std::string fTrackModuleLabel;
  //ShowerModuleLabel:          "showerrecopandora"

  std::string fPFPVertexAssnModuleLabel;
  std::string fPFPClusterAssnModuleLabel;
  std::string fPFPTrackAssnModuleLabel;

  float fMuonTrackLengthCut;
  float fTrackVertexProximityCut;
  float fShowerVertex2dProximityCut;
  float fShowerDetached2dProximityCut;
  float fMinMinDetachedShowersPerPlaneCut;
  float fMinMaxDetachedShowersPerPlaneCut;
  float fPadding;

  TTree* fmytree;
  int fnVtx;
};


PiZeroFilter::PiZeroFilter(fhicl::ParameterSet const & p)
  : fnVtx(0)
// Initialize member data here.
{
  this->reconfigure(p);
  art::ServiceHandle<art::TFileService> tfs;

  fmytree = tfs->make<TTree>("mytree","mytree");
  fmytree->Branch("fnVtx",&fnVtx,"fnVtx/I");

  // Call appropriate produces<>() functions here.
  produces<std::vector<ana::PiZeroROI> >();
}

bool PiZeroFilter::filter(art::Event & e)
{
  bool pass = false;

  std::cout << "Hello" << std::endl;
  // Implementation of required member function here.
  std::unique_ptr<std::vector<ana::PiZeroROI> > pizeroroiVector( new std::vector<ana::PiZeroROI> );
  //std::unique_ptr< art::Assns<recob::Vertex, ana::PiZeroROI::PiZeroROI > >  assnPiZeroROITagVertex( new art::Assns<recob::Vertex, anab::PiZeroROI>);

  art::ValidHandle<std::vector<recob::PFParticle> > Pfp_h = e.getValidHandle<std::vector<recob::PFParticle> >(fPFPModuleLabel);
  art::ValidHandle<std::vector<recob::Vertex> > Vtx_h = e.getValidHandle<std::vector<recob::Vertex> >(fVertexModuleLabel);
  art::ValidHandle<std::vector<recob::Cluster> > Cls_h = e.getValidHandle<std::vector<recob::Cluster> >(fClusterModuleLabel);
  art::ValidHandle<std::vector<recob::Track> > Trk_h = e.getValidHandle<std::vector<recob::Track> >(fTrackModuleLabel);

  if(!(Pfp_h.isValid() && Vtx_h.isValid() && Cls_h.isValid() && Trk_h.isValid())) 
    throw std::exception();

  const art::FindManyP<recob::Vertex> PfpVtx(Pfp_h, e, fPFPVertexAssnModuleLabel);
  const art::FindManyP<recob::Cluster> PfpCls(Pfp_h, e, fPFPClusterAssnModuleLabel);
  const art::FindManyP<recob::Track> PfpTrk(Pfp_h, e, fPFPTrackAssnModuleLabel);
  
  std::vector<recob::PFParticle> const& PfpVector(*Pfp_h);
  std::vector<recob::Vertex> const& VtxVector(*Vtx_h);
  std::vector<recob::Cluster> const& ClsVector(*Cls_h);
  std::vector<recob::Track> const& TrkVector(*Trk_h);

  std::cout << "PFPVector size: " << PfpVector.size() << std::endl;
  std::cout << "VtxVector size: " << VtxVector.size() << std::endl;
  std::cout << "ClsVector size: " << ClsVector.size() << std::endl;
  std::cout << "TrkVector size: " << TrkVector.size() << std::endl;
  
  std::cout << "Hello!" << std::endl;

  std::vector<ana::PiZeroROI> pizeroroi_v;
  std::vector<std::pair<int,int> > Vertex(3);
  std::vector<std::pair<int,int> > TimePairs(3);
  std::vector<std::pair<int,int> > WirePairs(3);

  std::map<int,double> nuMuonMaxTrackLength;
  std::map<int,int> nuMuonMaxTrackLengthIndex;
  std::map<int,std::vector<float> > nuMuonStartWire;
  std::map<int,std::vector<float> > nuMuonStartTick;
  std::map<int,std::vector<float> > startw;
  std::map<int,std::vector<float> > startt;
  std::map<int,std::vector<float> > endw;
  std::map<int,std::vector<float> > endt;
  std::map<int,std::vector<int> > nDetachedShowers;
  // iterate through all the PFParticles 
  for(auto const Pfp : PfpVector) {
    
    // Select only if Primary PFParticle is a neutrino
    if(Pfp.IsPrimary() && (Pfp.PdgCode()==12 || Pfp.PdgCode()==14 || Pfp.PdgCode()==-12 || Pfp.PdgCode()==-14)) { // Nu

      // Get neutrino vertex info
      auto const & v_ps = PfpVtx.at(Pfp.Self());
      // Save PFparticle vtx in v_ps should be size 1 because 
      // a PFparticle should only have one vertex
      if(v_ps.size() != 1) { std::cout << "PFParticle has more than one vtx?!" << std::endl; }
      
      //Store the neutrino vtx information in temporary container
      double xyz_p[3] = {0.,0.,0.};
      for(auto const & v_p : v_ps) {
	v_p->XYZ(xyz_p);
      }

      // Iteration through all PFParticle daughters 
      for(auto const idx : Pfp.Daughters()) {

	// Want to find a muon, which is defined as the longest track daughter within tolerance
	if(PfpVector.at(idx).PdgCode() == 13) { // Track-like object

	  //Checking the number of vertices associated with the track object
	  auto const & v_ds = PfpVtx.at(PfpVector.at(idx).Self());

	  if(v_ds.size() == 0) { 
	    //Skip the track if it has no vertex
	    continue;
	  } else if (v_ds.size() > 1) {
	    //Complain if the track contains more than one vertex
	    std::cout << "Daughter Track has more than one vertex!? " << v_ds.size() << std::endl;
	  }

	  //Store the track vtx information in temporary container	  
	  double xyz_d[3] = {0.,0.,0.};
	  for(auto const & v_d : v_ds) {
	    v_d->XYZ(xyz_d);
	  }

	  //Calculate the distance between the neutrino and track vertices
	  float dist = std::sqrt(std::pow(xyz_p[0]-xyz_d[0],2)+std::pow(xyz_p[1]-xyz_d[1],2)+std::pow(xyz_p[2]-xyz_d[2],2));

	  // Passes the track-Nu proximity threshold
	  if(dist<fTrackVertexProximityCut) { 

	    // Loop over proximate tracks to find longest track
	    auto const & trk_ds = PfpTrk.at(PfpVector.at(idx).Self());
	    // Make sure you actually grabbed a track
	    if(trk_ds.size() == 0) {
	      std::cout << "Failed to find the longest track!?" << std::endl;
	      continue;
	    } else if (trk_ds.size() > 1) {
	      // Check that you only grabbed one track
	      std::cout << "Grabbed " << trk_ds.size() << " Tracks instead of the longest trakc?!" << std::endl;
	    }

	    //Study the selectred track in detail
	    for(auto const & trk_d : trk_ds) {

	      //measure the end-to-end track length
	      float trkl = (trk_d->Vertex()-trk_d->End()).Mag();

	      //drop the track if it isn't long enough
	      if(trkl<fMuonTrackLengthCut){continue;}

	      //JOSEPH STOPPED COMMENTING HERE!!!!
	      if(nuMuonMaxTrackLength.find(idx) == nuMuonMaxTrackLength.end()) {
		nuMuonMaxTrackLength[idx] = trkl;
		nuMuonMaxTrackLengthIndex[idx] = PfpVector.at(idx).Self();
	      } else if (trkl > nuMuonMaxTrackLength[idx]) {
		nuMuonMaxTrackLength[idx] = trkl;
		nuMuonMaxTrackLengthIndex[idx] = PfpVector.at(idx).Self();		
	      }
	    }

	    // Loop over proximate tracks clusters to build potential ROIs
	    auto const & cls_ds = PfpCls.at(PfpVector.at(idx).Self());
	    for(auto const & cls_d : cls_ds) {
	      auto c_idx = cls_d->Plane().Plane;
	      if(startw.find(idx) == startw.end()) {
		startw[idx] = std::vector<float>{8256.,8256.,8256.};
		startt[idx] = std::vector<float>{9600.,9600.,9600.};
		endw[idx] = std::vector<float>{0.,0.,0.};
		endt[idx] = std::vector<float>{0.,0.,0.};
	      }
	      startw[idx][c_idx] = std::min(startw[idx][c_idx],std::min(cls_d->StartWire(),cls_d->EndWire()));
	      endw[idx][c_idx] = std::max(endw[idx][c_idx],std::max(cls_d->StartWire(),cls_d->EndWire()));
	      startt[idx][c_idx] = std::min(startt[idx][c_idx],std::min(cls_d->StartTick(),cls_d->EndTick()));
	      endt[idx][c_idx] = std::max(endt[idx][c_idx],std::max(cls_d->StartTick(),cls_d->EndTick()));
	    }
	  }
	}
      }
    }
  }
  // If there is no neutrino with a muon satisfying proximity and length cuts then the event does not pass
  //if(nuMuonMaxTrackLengthIndex.size() == 0)
  //  return false;

  // Loop over longest mouns and save cluster start point
  for(auto const & i : nuMuonMaxTrackLengthIndex) {
    nuMuonStartWire[i.first] = std::vector<float>{0.,0.,0.};
    nuMuonStartTick[i.first] = std::vector<float>{0.,0.,0.};
    auto const & cls_ds = PfpCls.at(PfpVector.at(i.second).Self());
    for(auto const & cls_d : cls_ds) {
      auto c_idx = cls_d->Plane().Plane;
      nuMuonStartWire[i.first][c_idx] = cls_d->StartWire();
      nuMuonStartTick[i.first][c_idx] = cls_d->StartTick();
    }
  }    

  // Loop over shower-like daughters of candidate vertices --> Loop over what nuMuonMaxTrackLengthIndex.first and then ask for PfpVector[ifirst].Daughters()
  //for(auto const Pfp : PfpVector) {

  //if(Pfp.IsPrimary() && (Pfp.PdgCode()==12 || Pfp.PdgCode()==14 || Pfp.PdgCode()==-12 || Pfp.PdgCode()==-14)) { // Nu

  // Loop over shower-like daughters of candidate vertices
  for(auto const n : nuMuonMaxTrackLengthIndex) {

    for(auto const idx : PfpVector.at(n.first).Daughters()) {

      if (PfpVector.at(idx).PdgCode() == 11) { // Shower-like

	auto const & cls_ds = PfpCls.at(PfpVector.at(idx).Self());
	for(auto const & cls_d : cls_ds) {
	  auto c_idx = cls_d->Plane().Plane;

	  //Loop over all vertex candidates and find best match
	  float mindist2d = 10000.0;
	  float mindist2didx = -1;
	  for(auto const & i : nuMuonStartWire) {
	    float dist2d = std::sqrt(std::pow(cls_d->StartWire()-nuMuonStartWire[i.first][c_idx],2)*0.3*0.3 // projected squared distance in cm^2 (0.3 cm/wire)
				     +std::pow(cls_d->StartTick()-nuMuonStartTick[i.first][c_idx],2)*0.05*0.05 // squared drift distance in cm^2 (0.05 cm/tick)
				     );
	    if(dist2d < mindist2d) {
	      mindist2d = dist2d;
	      mindist2didx = i.first; // neutrino index
	    }
	  }

	  // If shower satisfies proximity cut, add it to the correct ROI
	  if(mindist2d < fShowerVertex2dProximityCut && mindist2didx != -1) { 
	    if(startw.find(mindist2didx) == startw.end()) {
	      startw[mindist2didx] = std::vector<float>{8256.,8256.,8256.};
	      startt[mindist2didx] = std::vector<float>{9600.,9600.,9600.};
	      endw[mindist2didx] = std::vector<float>{0.,0.,0.};
	      endt[mindist2didx] = std::vector<float>{0.,0.,0.};
	    }
	    startw[mindist2didx][c_idx] = std::min(startw[mindist2didx][c_idx],std::min(cls_d->StartWire(),cls_d->EndWire()));
	    endw[mindist2didx][c_idx] = std::max(endw[mindist2didx][c_idx],std::max(cls_d->StartWire(),cls_d->EndWire()));
	    startt[mindist2didx][c_idx] = std::min(startt[mindist2didx][c_idx],std::min(cls_d->StartTick(),cls_d->EndTick()));
	    endt[mindist2didx][c_idx] = std::max(endt[mindist2didx][c_idx],std::max(cls_d->StartTick(),cls_d->EndTick()));

	    // If shower is detached, increment ROIs counter
	    if(mindist2d > fShowerDetached2dProximityCut) {
	      if(nDetachedShowers.find(mindist2didx) == nDetachedShowers.end())
		nDetachedShowers[mindist2didx] = std::vector<int>{0,0,0}; 
	      nDetachedShowers[mindist2didx][c_idx]++;
	    }
	  }
	} // loop over clusters of shower-like daughters
      } // if daughter is shower-like
    } // loop over track candidate daughters
  } // loop over track candidates
  
  // Loop over ROIs
  for(auto const & cand : nuMuonMaxTrackLengthIndex) {

    // If no ROI was built, does not pass even if there is a vertex candidate
    if(startw.find(cand.first)==startw.end() || startt.find(cand.first)==startt.end() || endw.find(cand.first)==endw.end() || endt.find(cand.first)==endt.end())
      continue;

    // If candidate does not satisfy shower cuts it does not pass
    int MinDetachedShowersPerPlane = 0;
    int MaxDetachedShowersPerPlane = 0;
    if(nDetachedShowers.find(cand.first) != nDetachedShowers.end()) {
      MinDetachedShowersPerPlane = std::min(nDetachedShowers[cand.first][0],std::min(nDetachedShowers[cand.first][1],nDetachedShowers[cand.first][2]));
      MaxDetachedShowersPerPlane = std::max(nDetachedShowers[cand.first][0],std::max(nDetachedShowers[cand.first][1],nDetachedShowers[cand.first][2]));
    }
    if(MinDetachedShowersPerPlane < fMinMinDetachedShowersPerPlaneCut && MaxDetachedShowersPerPlane < fMinMaxDetachedShowersPerPlaneCut)
      continue;

    pass = true;

    for(int i = 0; i<3; ++i) {
      Vertex[i] = std::make_pair(nuMuonStartTick[cand.first][i],nuMuonStartWire[cand.first][i]);
      // Need to define the upper limits on tick and wire number correctly
      TimePairs[i] = std::make_pair(std::max(0.,double(-1*fPadding)+startt[cand.first][i]),
				    std::min(9600.0,double(fPadding)+endt[cand.first][i]));
      WirePairs[i] = std::make_pair(std::max(0.,double(-1*fPadding)+startw[cand.first][i]),
				    std::min(8256.0,double(fPadding)+endw[cand.first][i]));
    }

    ana::PiZeroROI pizeroroi;
    pizeroroi.SetVertex( Vertex );
    pizeroroi.SetROI( WirePairs, TimePairs );
    pizeroroiVector->emplace_back(pizeroroi);

    fmytree->Fill();
  
  } // loop over candidates

  e.put( std::move(pizeroroiVector) );

  return pass;
  
}

void PiZeroFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fPFPModuleLabel = p.get<std::string>("PFPModuleLabel");
  fVertexModuleLabel = p.get<std::string>("VertexModuleLabel");
  fClusterModuleLabel = p.get<std::string>("ClusterModuleLabel");
  fTrackModuleLabel = p.get<std::string>("TrackModuleLabel");
  //ShowerModuleLabel:          "showerrecopandora"

  fPFPVertexAssnModuleLabel = p.get<std::string>("PFPVertexAssnModuleLabel");
  fPFPClusterAssnModuleLabel = p.get<std::string>("PFPClusterAssnModuleLabel");
  fPFPTrackAssnModuleLabel = p.get<std::string>("PFPTrackAssnModuleLabel");
  // Implementation of optional member function here.

  fMuonTrackLengthCut = p.get<float>("MuonTrackLengthCut");
  fTrackVertexProximityCut = p.get<float>("TrackVertexProximityCut");
  fShowerVertex2dProximityCut = p.get<float>("ShowerVertex2dProximityCut");
  fShowerDetached2dProximityCut = p.get<float>("ShowerDetached2dProximityCut");
  fMinMinDetachedShowersPerPlaneCut = p.get<int>("MinMinDetachedShowersPerPlaneCut");
  fMinMaxDetachedShowersPerPlaneCut = p.get<int>("MinMaxDetachedShowersPerPlaneCut");
  fPadding = p.get<float>("Padding");
}

DEFINE_ART_MODULE(PiZeroFilter)
