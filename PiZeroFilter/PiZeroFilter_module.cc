////////////////////////////////////////////////////////////////////////
// Class:       PiZeroFilter
// Module Type: filter
// File:        PiZeroFilter_module.cc
//
// Generated at Tue Mar  1 14:26:33 2016 by Matthew Toups using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "art/Framework/Services/Optional/TFileService.h"

#include "PiZeroROI/PiZeroROI.hh"
#include "RecoBase/PFParticle.h"
#include "RecoBase/Vertex.h"
#include "RecoBase/Track.h"
#include "RecoBase/Cluster.h"

class PiZeroFilter;

class PiZeroFilter : public art::EDFilter {
public:
  explicit PiZeroFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PiZeroFilter(PiZeroFilter const &) = delete;
  PiZeroFilter(PiZeroFilter &&) = delete;
  PiZeroFilter & operator = (PiZeroFilter const &) = delete;
  PiZeroFilter & operator = (PiZeroFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  // Declare member data here.
  std::string fPFPModuleLabel;
  std::string fVertexModuleLabel;
  std::string fClusterModuleLabel;
  std::string fTrackModuleLabel;
  //ShowerModuleLabel:          "showerrecopandora"

  std::string fPFPVertexAssnModuleLabel;
  std::string fPFPClusterAssnModuleLabel;
  std::string fPFPTrackAssnModuleLabel;

  TTree* fmytree;
  int fnVtx;
};


PiZeroFilter::PiZeroFilter(fhicl::ParameterSet const & p)
  : fnVtx(0)
// Initialize member data here.
{
  this->reconfigure(p);
  art::ServiceHandle<art::TFileService> tfs;

  fmytree = tfs->make<TTree>("mytree","mytree");
  fmytree->Branch("fnVtx",&fnVtx,"fnVtx/I");

  // Call appropriate produces<>() functions here.
  produces<std::vector<ana::PiZeroROI> >();
}

bool PiZeroFilter::filter(art::Event & e)
{
  //produces< std::vector<recob::PFParticle> >();
  //produces< std::vector<recob::Seed> >();
  //produces< std::vector<recob::Track> >();
  //produces< std::vector<recob::Vertex> >();
  //produces< art::Assns<recob::PFParticle, recob::SpacePoint> >();
  //produces< art::Assns<recob::PFParticle, recob::Cluster> >();
  //produces< art::Assns<recob::PFParticle, recob::Seed> >();
  //produces< art::Assns<recob::PFParticle, recob::Track> >();
  //produces< art::Assns<recob::PFParticle, recob::Vertex> >();
  //produces< art::Assns<recob::Track, recob::Hit> >();

  std::cout << "Hello" << std::endl;
  // Implementation of required member function here.
  std::unique_ptr<std::vector<ana::PiZeroROI> > pizeroroiVector( new std::vector<ana::PiZeroROI> );
  //std::unique_ptr< art::Assns<recob::Vertex, ana::PiZeroROI::PiZeroROI > >  assnPiZeroROITagVertex( new art::Assns<recob::Vertex, anab::PiZeroROI>);
  
  art::Handle<std::vector<recob::PFParticle> > Pfp_h;
  art::Handle<std::vector<recob::Vertex> > Vtx_h;
  art::Handle<std::vector<recob::Cluster> > Cls_h;
  art::Handle<std::vector<recob::Track> > Trk_h;

  std::cout << fPFPModuleLabel << fVertexModuleLabel << fClusterModuleLabel << fTrackModuleLabel << std::endl;
  e.getByLabel( fPFPModuleLabel, Pfp_h );
  e.getByLabel( fVertexModuleLabel, Vtx_h );
  e.getByLabel( fClusterModuleLabel, Cls_h );
  e.getByLabel( fTrackModuleLabel, Trk_h );

  if(!(Pfp_h.isValid() && Vtx_h.isValid() && Cls_h.isValid() && Trk_h.isValid())) 
    throw std::exception();
  
  std::vector<recob::PFParticle> const& PfpVector(*Pfp_h);
  std::vector<recob::Vertex> const& VtxVector(*Vtx_h);
  std::vector<recob::Cluster> const& ClsVector(*Cls_h);
  std::vector<recob::Track> const& TrkVector(*Trk_h);

  std::cout << "PFPVector size: " << PfpVector.size() << std::endl;
  std::cout << "VtxVector size: " << VtxVector.size() << std::endl;
  std::cout << "ClsVector size: " << ClsVector.size() << std::endl;
  std::cout << "TrkVector size: " << TrkVector.size() << std::endl;
  
  std::cout << "Hello!" << std::endl;
  fnVtx = 0;
  for(auto const Vtx : VtxVector) {
    std::cout << "VtxID: " << Vtx.ID() << std::endl;
    std::vector<std::pair<int, int> > VertexPairs;
    std::vector<std::pair<int, int> > TimePairs;
    std::vector<std::pair<int, int> > WirePairs;
    for(int i = 0; i<3; ++i) {
      VertexPairs.emplace_back(i,Vtx.ID());
      TimePairs.emplace_back(i+3,Vtx.ID());
      WirePairs.emplace_back(i+6,Vtx.ID());
    }
    ana::PiZeroROI pizeroroi;
    pizeroroi.SetVertex( VertexPairs );
    pizeroroi.SetROI( WirePairs, TimePairs );
    pizeroroiVector->emplace_back(pizeroroi);
    ++fnVtx;
  }
  std::cout << fnVtx << std::endl;
  fmytree->Fill();
  
  //util::CreateAssn(*this, e, *pizeroroiVector, vtx, *assnPiZeroROITagVertex);
  
  bool pass = false;
  if (pizeroroiVector->size() > 0 ) {
    pass = true;
  }

  e.put( std::move(pizeroroiVector) );

  return pass;
  
  //return true;
  //e.put( std::move(assnPiZeroROITagVertex) );
}

void PiZeroFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fPFPModuleLabel = p.get<std::string>("PFPModuleLabel");
  fVertexModuleLabel = p.get<std::string>("VertexModuleLabel");
  fClusterModuleLabel = p.get<std::string>("ClusterModuleLabel");
  fTrackModuleLabel = p.get<std::string>("TrackModuleLabel");
  //ShowerModuleLabel:          "showerrecopandora"

  fPFPVertexAssnModuleLabel = p.get<std::string>("PFPVertexAssnModuleLabel");
  fPFPClusterAssnModuleLabel = p.get<std::string>("PFPClusterAssnModuleLabel");
  fPFPTrackAssnModuleLabel = p.get<std::string>("PFPTrackAssnModuleLabel");
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(PiZeroFilter)
