////////////////////////////////////////////////////////////////////////
// Class:       PiZeroFilter
// Module Type: filter
// File:        PiZeroFilter_module.cc
//
// Generated at Tue Mar  1 14:26:33 2016 by Matthew Toups using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "art/Framework/Services/Optional/TFileService.h"

#include "PiZeroROI/PiZeroROI.hh"
#include "RecoBase/PFParticle.h"
#include "RecoBase/Vertex.h"
#include "RecoBase/Track.h"
#include "RecoBase/Cluster.h"

class PiZeroFilter;

class PiZeroFilter : public art::EDFilter {
public:
  explicit PiZeroFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PiZeroFilter(PiZeroFilter const &) = delete;
  PiZeroFilter(PiZeroFilter &&) = delete;
  PiZeroFilter & operator = (PiZeroFilter const &) = delete;
  PiZeroFilter & operator = (PiZeroFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  // Declare member data here.
  std::string fPFPModuleLabel;
  std::string fVertexModuleLabel;
  std::string fClusterModuleLabel;
  std::string fTrackModuleLabel;
  //ShowerModuleLabel:          "showerrecopandora"

  std::string fPFPVertexAssnModuleLabel;
  std::string fPFPClusterAssnModuleLabel;
  std::string fPFPTrackAssnModuleLabel;

  float fMuonTrackLengthCut;
  float fTrackVertexProximityCut;
  float fShowerVertex2dProximityCut;
  float fShowerDetached2dProximityCut;
  float fMinMinDetachedShowersPerPlaneCut;
  float fMinMaxDetachedShowersPerPlaneCut;

  TTree* fmytree;
  int fnVtx;
};


PiZeroFilter::PiZeroFilter(fhicl::ParameterSet const & p)
  : fnVtx(0)
// Initialize member data here.
{
  this->reconfigure(p);
  art::ServiceHandle<art::TFileService> tfs;

  fmytree = tfs->make<TTree>("mytree","mytree");
  fmytree->Branch("fnVtx",&fnVtx,"fnVtx/I");

  // Call appropriate produces<>() functions here.
  produces<std::vector<ana::PiZeroROI> >();
}

bool PiZeroFilter::filter(art::Event & e)
{
  bool pass = false;
  //produces< std::vector<recob::PFParticle> >();
  //produces< std::vector<recob::Seed> >();
  //produces< std::vector<recob::Track> >();
  //produces< std::vector<recob::Vertex> >();
  //produces< art::Assns<recob::PFParticle, recob::SpacePoint> >();
  //produces< art::Assns<recob::PFParticle, recob::Cluster> >();
  //produces< art::Assns<recob::PFParticle, recob::Seed> >();
  //produces< art::Assns<recob::PFParticle, recob::Track> >();
  //produces< art::Assns<recob::PFParticle, recob::Vertex> >();
  //produces< art::Assns<recob::Track, recob::Hit> >();

  std::cout << "Hello" << std::endl;
  // Implementation of required member function here.
  std::unique_ptr<std::vector<ana::PiZeroROI> > pizeroroiVector( new std::vector<ana::PiZeroROI> );
  //std::unique_ptr< art::Assns<recob::Vertex, ana::PiZeroROI::PiZeroROI > >  assnPiZeroROITagVertex( new art::Assns<recob::Vertex, anab::PiZeroROI>);

  art::ValidHandle<std::vector<recob::PFParticle> > Pfp_h = e.getValidHandle<std::vector<recob::PFParticle> >(fPFPModuleLabel);
  art::ValidHandle<std::vector<recob::Vertex> > Vtx_h = e.getValidHandle<std::vector<recob::Vertex> >(fVertexModuleLabel);
  art::ValidHandle<std::vector<recob::Cluster> > Cls_h = e.getValidHandle<std::vector<recob::Cluster> >(fClusterModuleLabel);
  art::ValidHandle<std::vector<recob::Track> > Trk_h = e.getValidHandle<std::vector<recob::Track> >(fTrackModuleLabel);

  if(!(Pfp_h.isValid() && Vtx_h.isValid() && Cls_h.isValid() && Trk_h.isValid())) 
    throw std::exception();

  const art::FindManyP<recob::Vertex> PfpVtx(Pfp_h, e, fPFPVertexAssnModuleLabel);
  const art::FindManyP<recob::Cluster> PfpCls(Pfp_h, e, fPFPClusterAssnModuleLabel);
  const art::FindManyP<recob::Track> PfpTrk(Pfp_h, e, fPFPTrackAssnModuleLabel);

  //art::ValidHandle<std::vector<recob::PFParticle> > Pfp_h;
  //art::ValidHandle<std::vector<recob::Vertex> > Vtx_h;
  //art::ValidHandle<std::vector<recob::Cluster> > Cls_h;
  //art::ValidHandle<std::vector<recob::Track> > Trk_h;

  //std::cout << fPFPModuleLabel << fVertexModuleLabel << fClusterModuleLabel << fTrackModuleLabel << std::endl;
  //e.getByLabel( fPFPModuleLabel, Pfp_h );
  //e.getByLabel( fVertexModuleLabel, Vtx_h );
  //e.getByLabel( fClusterModuleLabel, Cls_h );
  //e.getByLabel( fTrackModuleLabel, Trk_h );

  //const art::FindManyP<recob::Hit> findManyHits(clusterHandle, event, fClusterProducerLabel);
  
  std::vector<recob::PFParticle> const& PfpVector(*Pfp_h);
  std::vector<recob::Vertex> const& VtxVector(*Vtx_h);
  std::vector<recob::Cluster> const& ClsVector(*Cls_h);
  std::vector<recob::Track> const& TrkVector(*Trk_h);

  std::cout << "PFPVector size: " << PfpVector.size() << std::endl;
  std::cout << "VtxVector size: " << VtxVector.size() << std::endl;
  std::cout << "ClsVector size: " << ClsVector.size() << std::endl;
  std::cout << "TrkVector size: " << TrkVector.size() << std::endl;
  
  std::cout << "Hello!" << std::endl;

  // Compute ROI
  std::vector<ana::PiZeroROI> pizeroroi_v;
  std::vector<std::pair<int,int> > Vertex(3);
  std::vector<std::pair<int,int> > TimePairs(3);
  std::vector<std::pair<int,int> > WirePairs(3);
  for(auto const Pfp : PfpVector) {

    if(Pfp.IsPrimary() && (Pfp.PdgCode()==12 || Pfp.PdgCode()==14 || Pfp.PdgCode()==-12 || Pfp.PdgCode()==-14)) { // Nu

      // Get Vertex info
      //const & recob::Vertex v_p = PfpVtx.at(Pfp.Self());
      auto const & v_ps = PfpVtx.at(Pfp.Self());
      if(v_ps.size() != 1) { 
	std::cout << "I Hate My Life!" << std::endl;
      }
      double xyz_p[3];
      for(auto const & v_p : v_ps) {
	v_p->XYZ(xyz_p);
      }

      // Find muon which is defined as longest track near neutrino vertex within tolerance
      float max_trkl = -1;
      int max_trkl_idx = -1;
      for(auto idx : Pfp.Daughters()) {

        //const & recob::Vertex v_d = PfpVtx.at(PfpVector.at(idx).Self());
	auto const & v_ds = PfpVtx.at(PfpVector.at(idx).Self());
	if(v_ds.size() != 1) { 
	  std::cout << "I Hate My Life! 222222222" << std::endl;
	}
        double xyz_d[3];
        for(auto const & v_d : v_ds) {
	  v_d->XYZ(xyz_d);
	}
        float dist = std::sqrt(std::pow(xyz_p[0]-xyz_d[0],2)+std::pow(xyz_p[1]-xyz_d[1],2)+std::pow(xyz_p[2]-xyz_d[2],2));

	if(PfpVector.at(idx).PdgCode() == 13 && dist<fTrackVertexProximityCut) { // Muon

	  //const & recob::Track trk_d = PfpTrk.at(PfpVector.at(idx).Self());
	  auto const & trk_ds = PfpTrk.at(PfpVector.at(idx).Self());
	  if(trk_ds.size() != 1) {
	    std::cout << "I Hate My Life! 33333333" << std::endl;
	  }
	  for(auto const & trk_d : trk_ds) {
	    float trkl = (trk_d->Vertex()-trk_d->End()).Mag();

	    if(trkl > max_trkl) {
	      max_trkl = trkl;
	      max_trkl_idx = idx;
	    }	    
	  }
	}
      }
      // If there is no muon then look for next neutrino vertex in event
      if(max_trkl_idx == -1 || max_trkl<fMuonTrackLengthCut) 
	continue;

      float pstartw[3] = {0.};
      float pstartt[3] = {0.};
      float startw[3] = {0.};
      float startt[3] = {0.};
      float endw[3] = {0.};
      float endt[3] = {0.};
      unsigned int nDetachedShowers[3] = {0};
      for(auto const idx : Pfp.Daughters()) {

	// Get daughters of neutrino and associated tracks
	//const & recob::Vertex v_d = PfpVtx.at(PfpVector.at(idx).Self());	
	auto const & v_ds = PfpVtx.at(PfpVector.at(idx).Self());	
        if(v_ds.size() != 1) {
	  std::cout << "I Hate My Life! 4444444444444" << std::endl;
        }	
	double xyz_d[3];
	for(auto const & v_d : v_ds) {
	  v_d->XYZ(xyz_d);
	}
	float dist = std::sqrt(std::pow(xyz_p[0]-xyz_d[0],2)+std::pow(xyz_p[1]-xyz_d[1],2)+std::pow(xyz_p[2]-xyz_d[2],2));

	if(PfpVector.at(idx).PdgCode() == 13) { // Muon
	  //If track is close enough to the neutrino vertex
	  if(dist < fTrackVertexProximityCut) { 
	    //const & recob::Cluster cls_d = PfpCls.at(PfpVector.at(idx).Self());
	    auto const & cls_ds = PfpCls.at(PfpVector.at(idx).Self());
	    for(auto const & cls_d : cls_ds) {
	      auto c_idx = cls_d->Plane().Plane;
	      startw[c_idx] = std::min(startw[c_idx],std::min(cls_d->StartWire(),cls_d->EndWire()));
	      endw[c_idx] = std::max(endw[c_idx],std::max(cls_d->StartWire(),cls_d->EndWire()));
	      startt[c_idx] = std::min(startt[c_idx],std::min(cls_d->StartTick(),cls_d->EndTick()));
	      endt[c_idx] = std::max(endt[c_idx],std::max(cls_d->StartTick(),cls_d->EndTick()));
	      if(int(idx) == max_trkl_idx) {
		pstartw[c_idx] = startw[c_idx];
		pstartt[c_idx] = startt[c_idx];
	      }
	    }
	  }
	} else if (PfpVector.at(idx).PdgCode() == 11) { // Shower
	  //If track is close enough to the neutrino vertex
	  auto const & cls_ds = PfpCls.at(PfpVector.at(idx).Self());
	  for(auto const & cls_d : cls_ds) {
	    auto c_idx = cls_d->Plane().Plane;
	    float dist2d = std::sqrt(std::pow(cls_d->StartWire()-pstartw[c_idx],2)+std::pow(cls_d->StartTick()-pstartt[c_idx],2));
	    if(dist2d < fShowerVertex2dProximityCut) { 
	      startw[c_idx] = std::min(startw[c_idx],std::min(cls_d->StartWire(),cls_d->EndWire()));
	      endw[c_idx] = std::max(endw[c_idx],std::max(cls_d->StartWire(),cls_d->EndWire()));
	      startt[c_idx] = std::min(startt[c_idx],std::min(cls_d->StartTick(),cls_d->EndTick()));
	      endt[c_idx] = std::max(endt[c_idx],std::max(cls_d->StartTick(),cls_d->EndTick()));
	    }
	    if(dist2d > fShowerDetached2dProximityCut) 
	      nDetachedShowers[c_idx]++;
	  }
	} else {
	  std::cout << "NOOOOOOOO" << std::endl;
	}
      } // loop over daughters
      unsigned int MinDetachedShowersPerPlane = std::min(nDetachedShowers[0],std::min(nDetachedShowers[1],nDetachedShowers[2]));
      unsigned int MaxDetachedShowersPerPlane = std::max(nDetachedShowers[0],std::max(nDetachedShowers[1],nDetachedShowers[2]));
      if(MinDetachedShowersPerPlane < fMinMinDetachedShowersPerPlaneCut && MaxDetachedShowersPerPlane < fMinMaxDetachedShowersPerPlaneCut)
	continue;

      pass = true;

      for(int i = 0; i<3; ++i) {
	Vertex[i] = std::make_pair(pstartt[i],pstartw[i]);
	TimePairs[i] = std::make_pair(startt[i],endt[i]);
	WirePairs[i] = std::make_pair(startw[i],endw[i]);
      }
      ana::PiZeroROI pizeroroi;
      pizeroroi.SetVertex( Vertex );
      pizeroroi.SetROI( WirePairs, TimePairs );
      pizeroroiVector->emplace_back(pizeroroi);

      fmytree->Fill();
  
    } // neutrino
  } // loop over PFParticles

  e.put( std::move(pizeroroiVector) );

  return pass;
  
  //return true;
  //e.put( std::move(assnPiZeroROITagVertex) );
}

void PiZeroFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fPFPModuleLabel = p.get<std::string>("PFPModuleLabel");
  fVertexModuleLabel = p.get<std::string>("VertexModuleLabel");
  fClusterModuleLabel = p.get<std::string>("ClusterModuleLabel");
  fTrackModuleLabel = p.get<std::string>("TrackModuleLabel");
  //ShowerModuleLabel:          "showerrecopandora"

  fPFPVertexAssnModuleLabel = p.get<std::string>("PFPVertexAssnModuleLabel");
  fPFPClusterAssnModuleLabel = p.get<std::string>("PFPClusterAssnModuleLabel");
  fPFPTrackAssnModuleLabel = p.get<std::string>("PFPTrackAssnModuleLabel");
  // Implementation of optional member function here.

  fMuonTrackLengthCut = p.get<float>("MuonTrackLengthCut");
  fTrackVertexProximityCut = p.get<float>("TrackVertexProximityCut");
  fShowerVertex2dProximityCut = p.get<float>("ShowerVertex2dProximityCut");
  fShowerDetached2dProximityCut = p.get<float>("ShowerDetached2dProximityCut");
  fMinMinDetachedShowersPerPlaneCut = p.get<int>("MinMinDetachedShowersPerPlaneCut");
  fMinMaxDetachedShowersPerPlaneCut = p.get<int>("MinMaxDetachedShowersPerPlaneCut");
}

DEFINE_ART_MODULE(PiZeroFilter)
