////////////////////////////////////////////////////////////////////////
// Class:       PiZeroFilter
// Module Type: filter
// File:        PiZeroFilter_module.cc
//
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardata/Utilities/AssociationUtil.h"

#include <memory>

#include "art/Framework/Services/Optional/TFileService.h"

#include "PiZeroROI/PiZeroROI.hh"
#include "lardata/RecoBase/PFParticle.h"
#include "lardata/RecoBase/Vertex.h"
#include "lardata/RecoBase/Track.h"
#include "lardata/RecoBase/Cluster.h"
#include "lardata/RecoBase/Hit.h"

#include "lardata/MCBase/MCShower.h"

#include "larcore/Geometry/GeometryCore.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/CryostatGeo.h"
#include "larcore/Geometry/PlaneGeo.h"
#include "larcore/Geometry/OpDetGeo.h"
#include "larcore/Geometry/WireGeo.h"
#include "larcore/Geometry/TPCGeo.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/Utilities/GeometryUtilities.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"

class PiZeroFilter;

class PiZeroFilter : public art::EDFilter {
public:
  explicit PiZeroFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  // Plugins should not be copied or assigned.
  PiZeroFilter(PiZeroFilter const &) = delete;
  PiZeroFilter(PiZeroFilter &&) = delete;
  PiZeroFilter & operator = (PiZeroFilter const &) = delete;
  PiZeroFilter & operator = (PiZeroFilter &&) = delete;
  
  // Required functions.
  bool filter(art::Event & e) override;
  
  // Selected optional functions.
  void reconfigure(fhicl::ParameterSet const & p) override;

private:
  
  // Declare member data here.
  std::string fPFPModuleLabel;
  std::string fPFPModuleLabelCosmic;
  std::string fVertexModuleLabel;
  std::string fClusterModuleLabel;
  std::string fTrackModuleLabel;
  std::string fCCInclusiveModuleLabel;

    
  float fMuonTrackLengthCut;
  float fShortTrackLengthCut;
  float fShowerLengthCut;
  float fProximityCutToVertex;
  float fTrackVertexProximityCut;
  float fCosmicTrackVertexProximityCut;
  float fShowerVertex2dProximityCut;
  float fShowerDetached2dProximityCut;
  float fMinDistanceAnyCluster;

  bool  fNotCheckDetachmentAtAll;
  bool  fUseShowerLengthCut;
  bool  fCheckTrackOverlap;
  bool  fCheckCosmicOverlap;
  bool  fCheckOverlapAllPFParticles;
  bool  fCheckDetachmentToOtherShowers;
  bool  fUseVerticesForDetachedCut;
  bool  fRejectMoreThanOneRecoNeutrino;

  int   fMaxNeutrinoShowers;
  int   fMaxCloseTracks;
  int   fMaxCosmicTracks;
  
  int   fMinDetachedShowersIn2Views;
  int   fMinDetachedShowersIn3Views;

  float fPadding;
  
  TTree* fallEventTree;
  int fnVtx;
  int fnShw;
  int fnTrk;
  int fnNuMuCC;
  
  TTree* fselectedEventTree;
  int fnTrkSelected;
  double fTrkLengths;
  double fdeltaVtx;
  int fnAllTrkSelected;
  int fnAllShowSelected;
  
  TTree* fMCEventTree;
  int fnTrkMC;
  int fnShwMC;
  int fnMCNuMuCC;
  int fMCPdg;

  const bool NeutrinoHasAtLeastTwoShowerObjects(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticlesToTracks pfParticleToTrackMap, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, std::vector<size_t>& showerIDs, art::Ptr<recob::Vertex> nuVertex, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap);

  const bool IsShortTrack(const art::Ptr<recob::PFParticle> track,lar_pandora::PFParticlesToTracks pfParticleToTrackMap);

  const bool IsCloseTrack(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToTracks pfParticleToTrackMap, art::Ptr<recob::Vertex> nuVertex);

  const bool CheckShowerLength(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToClusters pfParticleToClusterMap);

  const bool IsDetachedFromVertex(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToTracks pfParticleToTracksMap, art::Ptr<recob::Vertex> nuVertex, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap);

  const int GetNCloseTracks(const art::Ptr<recob::PFParticle> particle, art::Ptr<recob::Vertex> nuVertex, lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticlesToTracks pfParticleToTrackMap) const;

  const int GetNCloseCosmics(art::Ptr<recob::Vertex> nuVertex, lar_pandora::PFParticleVector pfParticleListCosmic, lar_pandora::PFParticlesToTracks pfParticleToTrackMapCosmic) const;

  const int NDetachedClusters(art::Ptr<recob::PFParticle> particle, art::Ptr<recob::PFParticle> track, art::Ptr<recob::PFParticle> shower, lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticleVector pfParticleListCosmic, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::PFParticlesToClusters pfParticleToClusterMapCosmic, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHitsCosmic) const;

  const bool UseCosmicCluster(art::Ptr<recob::Cluster> cosmicCluster,lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHitsCosmic) const;

  const float GetClosestDistance(art::Ptr<recob::Cluster> showerCluster, art::Ptr<recob::Cluster> cosmicCluster) const;

  const bool DetachedSegments(float p1x, float p2x, float p1y, float p2y, float q1x, float q2x,float q1y, float q2y) const;

  const bool IsDetached(art::Ptr<recob::PFParticle> track, art::Ptr<recob::PFParticle> shower, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap) const;

  const bool CheckTrackOverlap(lar_pandora::PFParticleVector pfParticleList, const art::Ptr<recob::PFParticle> particle, const art::Ptr<recob::PFParticle> track, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::ClustersToHits clustersToHits) const;

  const bool CheckOverlap(art::Ptr<recob::Cluster> trackCluster, art::Ptr<recob::Cluster> showerCluster, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHits2) const;

  const bool CheckOverlapAllPFParticles(lar_pandora::PFParticleVector pfParticleList, const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::ClustersToHits clustersToHits) const;

  const bool CheckCosmicOverlap(lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticleVector pfParticleListCosmic, const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::PFParticlesToClusters pfParticleToClusterMapCosmic, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHitsCosmic) const;
  
  bool CheckShowerObjects(const art::Ptr<recob::PFParticle> particle, art::Ptr<recob::PFParticle> longestTrack, lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticleVector pfParticleListCosmic, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::PFParticlesToClusters pfParticleToClusterMapCosmic, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHitsCosmic, std::vector<size_t>& showers, std::vector<size_t>& showersFinal);

  bool BuildROI(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticleVector pfParticleList,art::Ptr<recob::PFParticle> longestTrack, std::vector<size_t> showerIDs, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap, std::vector<std::pair<int,int> > & Vertex, std::vector<float> & MuonVertex, std::vector<std::pair<int,int> > & TrackEnd,  std::vector<std::pair<int,int> > & WirePairs, std::vector<std::pair<int,int> > & TimePairs, std::vector<std::pair<int,int> > & PiZeroWirePairs, std::vector<std::pair<int,int> > & PiZeroTimePairs);
    
};


PiZeroFilter::PiZeroFilter(fhicl::ParameterSet const & p)
  : fnVtx(0),
    fnShw(0),
    fnNuMuCC(0),
    fnTrkSelected(0),
    fdeltaVtx(0.0),
    fnAllTrkSelected(0),
    fnAllShowSelected(0)
    
    
    // Initialize member data here.
{
  this->reconfigure(p);
  art::ServiceHandle<art::TFileService> tfs;
  fallEventTree = tfs->make<TTree>("allEvents","allEvents");
  fallEventTree->Branch("fnVtx",&fnVtx,"fnVtx/I");
  fallEventTree->Branch("fnShw",&fnShw,"fnShw/I");
  fallEventTree->Branch("fnTrk",&fnTrk,"fnTrk/I");
  fallEventTree->Branch("fnNuMuCC",&fnNuMuCC,"fnNuMuCC/I");
  
  fselectedEventTree = tfs->make<TTree>("selectedEvents","selectedEvents");
  fselectedEventTree->Branch("fdeltaVtx",&fdeltaVtx,"fdeltaVtx/D");
  fselectedEventTree->Branch("fTrkLengths",&fTrkLengths,"fTrkLengths/D");
  fselectedEventTree->Branch("fnTrkSelected",&fnTrkSelected,"fnTrkSelected/I");
  fselectedEventTree->Branch("fnAllTrkSelected",&fnAllTrkSelected,"fnAllTrkSelected/I");
  fselectedEventTree->Branch("fnAllShowSelected",&fnAllShowSelected,"fnAllShowSelected/I");
  
  fMCEventTree = tfs->make<TTree>("MCEvents","MCEvents");
  fMCEventTree->Branch("fnTrkMC",&fnTrkMC,"fnTrkMC/I");
  fMCEventTree->Branch("fnShwMC",&fnShwMC,"fnShwMC/I");
  fMCEventTree->Branch("fnMCNuMuCC",&fnMCNuMuCC,"fnMCNuMuCC/I");
  fMCEventTree->Branch("fMCPdg",&fMCPdg,"fMCPdg/I");
  // Call appropriate produces<>() functions here.
  produces<std::vector<ana::PiZeroROI> >();
  produces<art::Assns<recob::PFParticle, ana::PiZeroROI> >();
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool PiZeroFilter::filter(art::Event & e)
{
  
  bool pass = false;

  // Implementation of required member function here.
  std::unique_ptr<std::vector<ana::PiZeroROI> > pizeroroiVector( new std::vector<ana::PiZeroROI> );
  //std::unique_ptr< art::Assns<recob::Vertex, ana::PiZeroROI::PiZeroROI > >  assnPiZeroROITagVertex( new art::Assns<recob::Vertex, anab::PiZeroROI>);

  //declaration of variables to be used to store ROIss
  std::vector< int > roi_cand_v;  
  std::vector< double > trk_lengths; 
    
  std::map<int,double> nuMuonMaxTrackLength;
  std::map<int,int> nuMuonMaxTrackLengthIndex;
  std::map<int,std::vector<float> > nuMuonStartWire;
  std::map<int,std::vector<float> > nuMuonStartTick;
  std::map<int,std::vector<int> > nDetachedShowers;

  std::vector<ana::PiZeroROI> pizeroroi_v;
  std::vector<std::pair<int,int> > Vertex(3);
  std::vector<std::pair<int,int> > TrackEnd(3);
  std::vector<std::pair<int,int> > TimePairs(3);
  std::vector<std::pair<int,int> > WirePairs(3);
  std::vector<std::pair<int,int> > PiZeroTimePairs(3);
  std::vector<std::pair<int,int> > PiZeroWirePairs(3);
  std::vector< float > CCIncVertex(3);
  std::vector< float > MuonVertex(3);
  std::vector< float > NeutrinoVertex(3);

  //Attempt at making an association between PFParticle and ROI
  std::unique_ptr<art::Assns<recob::PFParticle, ana::PiZeroROI> > ROI_PFP_Assn(new art::Assns<recob::PFParticle, ana::PiZeroROI>); 
    
  // * PFParticles
  //These vectors and maps will contain the associations between pfparticles and vertices, tracks, clusters, etc
  //these vectors and maps are filled up inside LArPandoraHelper, should have the right associations
  //careful with usage though: inside LArPandoraHelper, loop over e.g. tracks, not saving entry for a PFParticle without track

  lar_pandora::PFParticleVector pfParticleList; //vector of PFParticles
  lar_pandora::PFParticleVector pfParticleListCosmic; //vector of PFParticles for Cosmics
  lar_pandora::VertexVector vertexVector; //vector of vertices
  lar_pandora::VertexVector vertexVectorCosmic; //vector of vertices for Cosmics
  lar_pandora::TrackVector allPfParticleTracks; //all PFParticle tracks
  lar_pandora::TrackVector allPfParticleTracksCosmic; //all PFParticle tracks for Cosmics
  lar_pandora::ClusterVector clusterVector; //vector of clusters
  lar_pandora::ClusterVector clusterVectorCosmic; //vector of clusters for Cosmics
  lar_pandora::PFParticlesToClusters pfParticleToClusterMap; //PFParticle-to-cluster map
  lar_pandora::PFParticlesToClusters pfParticleToClusterMapCosmic; //PFParticle-to-cluster map for Cosmics
  lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap; //PFParticle-to-vertex map
  lar_pandora::PFParticlesToVertices pfParticlesToVerticesMapCosmic; //PFParticle-to-vertex map for Cosmics
  lar_pandora::PFParticlesToTracks pfParticleToTrackMap; //PFParticle-to-track map
  lar_pandora::PFParticlesToTracks pfParticleToTrackMapCosmic; //PFParticle-to-track map for Cosmics
  lar_pandora::TracksToHits pfTracksToHitsMapCosmic; //PFParticle-to-track map for Cosmics
  lar_pandora::ClustersToHits clustersToHits; //Clusters-to-hits
  lar_pandora::ClustersToHits clustersToHitsCosmic; //Clusters-to-hits for Cosmics
  
  
  lar_pandora::LArPandoraHelper::CollectPFParticles(e, fPFPModuleLabel, pfParticleList, pfParticleToClusterMap); //collect PFParticles and map to clusters

  lar_pandora::LArPandoraHelper::CollectPFParticles(e, fPFPModuleLabelCosmic, pfParticleListCosmic, pfParticleToClusterMapCosmic); //collect PFParticles and map to clusters for Cosmics

  std::cout << "Number of PFParticles = "<< pfParticleList.size() << std::endl;

  if(pfParticleList.size()<4)
    {
      e.put( std::move(pizeroroiVector) );                                                                                              
      e.put( std::move(ROI_PFP_Assn) );                                                                                                       
      return false; 
    }

  lar_pandora::LArPandoraHelper::CollectVertices(e, fPFPModuleLabel, vertexVector, pfParticlesToVerticesMap); //map PFParticles-to-vertex
  lar_pandora::LArPandoraHelper::CollectTracks(e, fPFPModuleLabel, allPfParticleTracks, pfParticleToTrackMap);//map PFParticles-to-tracks
  lar_pandora::LArPandoraHelper::CollectClusters(e, fPFPModuleLabel, clusterVector, clustersToHits);//map Clusters-to-hits

  //for cosmics
  lar_pandora::LArPandoraHelper::CollectVertices(e, fPFPModuleLabelCosmic, vertexVectorCosmic, pfParticlesToVerticesMapCosmic); 
  //  lar_pandora::LArPandoraHelper::CollectTracks(e, fPFPModuleLabelCosmic, allPfParticleTracksCosmic, pfParticleToTrackMapCosmic);
  lar_pandora::LArPandoraHelper::CollectTracks(e, fPFPModuleLabelCosmic, allPfParticleTracksCosmic, pfTracksToHitsMapCosmic);
  lar_pandora::LArPandoraHelper::CollectClusters(e, fPFPModuleLabelCosmic, clusterVectorCosmic, clustersToHitsCosmic);






  //get the output from CC inclusive filter
  art::Handle<art::Assns<recob::Vertex, recob::Track>> vtxTrackAssnsHandle;
  e.getByLabel( fCCInclusiveModuleLabel, vtxTrackAssnsHandle);

  size_t nuID = static_cast<size_t>(-1);
  size_t muonID = static_cast<size_t>(-1);

  if (!vtxTrackAssnsHandle.isValid()) 
    //throw std::exception();
    {
      e.put( std::move(pizeroroiVector) );
      e.put( std::move(ROI_PFP_Assn) );                                                                                                     
      return false;
    }
  const art::Assns<recob::Vertex, recob::Track>& vtxTrackAssns = *vtxTrackAssnsHandle;

  if(vtxTrackAssns.size()!=1)
    std::cerr << "Error, more than one vertex associated from CC inclusive filter" << std::endl;

  for(size_t idx = 0; idx < vtxTrackAssns.size(); idx++)
    {
      const art::Ptr<recob::Vertex>& vertex = vtxTrackAssns.at(idx).first;
      const art::Ptr<recob::Track>&  track  = vtxTrackAssns.at(idx).second;

      muonID = track.key(); //checked this is the correct PFParticle ID in the list from PandoraNu

      //cut on the length of the track
      const float trkl = (track->Vertex()-track->End()).Mag();

      if(trkl<fMuonTrackLengthCut)
	{
	  e.put( std::move(pizeroroiVector) );
	  e.put( std::move(ROI_PFP_Assn) );
	  return false;
	}

      double xyz_0[3] = {0.0, 0.0, 0.0} ;
      vertex->XYZ(xyz_0);
      CCIncVertex[0]= xyz_0[0];
      CCIncVertex[1]= xyz_0[1];
      CCIncVertex[2]= xyz_0[2];      
    }

  
  //Added a check to have one and only one neutrino for a cleaner sample - default disabled, should not be enabled with cosmics
  short nprim = 0;
  bool found_neutrino = false;
  for (unsigned int n = 0; n < pfParticleList.size(); ++n)
    {
      const art::Ptr<recob::PFParticle> particle = pfParticleList.at(n);
      if (particle->IsPrimary() && lar_pandora::LArPandoraHelper::IsNeutrino(particle))
	{
	  nprim++;
	  //check if the muon selected by the CC inclusive filter is its daughter
	  const std::vector<size_t> &daughterIDs = particle->Daughters();
	  for (size_t j = 0; j < daughterIDs.size(); ++j) // loop over neutrino daughters                                              
	    {
	      if(muonID == daughterIDs[j])
		{
		  found_neutrino = true;
		  nuID = n;
		}
	    }
	}
    }
  
  if(!found_neutrino)
    {
      e.put( std::move(pizeroroiVector) );
      e.put( std::move(ROI_PFP_Assn) );

      return false;
    }
  
  // Reject event if more than one neutrino reconstructed
  if(fRejectMoreThanOneRecoNeutrino)
    {
      if(nprim!=1) 
	{
	  e.put( std::move(pizeroroiVector) );
	  e.put( std::move(ROI_PFP_Assn) );
	  
	  return false;
	}
    }
  
  const art::Ptr<recob::PFParticle> particle = pfParticleList.at(nuID);	  
  
  lar_pandora::PFParticlesToVertices::const_iterator vIter = pfParticlesToVerticesMap.find(particle);
  
  if (pfParticlesToVerticesMap.end() != vIter)
    {
      const lar_pandora::VertexVector &vertexVector = vIter->second;
      
      if (!vertexVector.empty())
	{
	  if (vertexVector.size() == 1)
	    {
	      //if there is one vertex, store it
	      art::Ptr<recob::Vertex> nuVertex = vertexVector.front();
	      
	      double xyz_0[3] = {0.0, 0.0, 0.0} ;
	      nuVertex->XYZ(xyz_0);
	      NeutrinoVertex[0] = xyz_0[0];
	      NeutrinoVertex[1] = xyz_0[1];
	      NeutrinoVertex[2] = xyz_0[2];

	      std::vector<size_t> showerIDs;
	      
	      if (!this->NeutrinoHasAtLeastTwoShowerObjects(particle,pfParticleList, pfParticleToTrackMap, pfParticleToClusterMap,showerIDs, nuVertex, pfParticlesToVerticesMap))
		{
		  e.put( std::move(pizeroroiVector) );
		  e.put( std::move(ROI_PFP_Assn) );

		  return false;
		}
	      
	      const int n_close_tracks = this->GetNCloseTracks(particle, nuVertex, pfParticleList,pfParticleToTrackMap);
	      
	      if (fnShw > fMaxNeutrinoShowers || n_close_tracks > fMaxCloseTracks)
		{
		  e.put( std::move(pizeroroiVector) );
		  e.put( std::move(ROI_PFP_Assn) );
		  
		  return false;
		}
	      
	      const int n_close_cosmics = this->GetNCloseCosmics(nuVertex, pfParticleListCosmic, pfParticleToTrackMapCosmic);

	      if (n_close_cosmics > fMaxCosmicTracks)
		{
		  e.put( std::move(pizeroroiVector) );
		  e.put( std::move(ROI_PFP_Assn) );

		  return false;
		}
	      
	      //"longest track" (aka muon candidate) comes now from the CC inclusive filter - doesn't have to be the longest
	      art::Ptr<recob::PFParticle> longestTrack = pfParticleList.at(muonID); 
	      
	      std::vector<size_t> showerIDsFinal;
	      if(!this->CheckShowerObjects(particle, longestTrack, pfParticleList, pfParticleListCosmic,pfParticleToClusterMap, pfParticleToClusterMapCosmic, pfParticlesToVerticesMap, clustersToHits,clustersToHitsCosmic, showerIDs, showerIDsFinal))
		{
		  e.put( std::move(pizeroroiVector) );
		  e.put( std::move(ROI_PFP_Assn) );

		  return false;
		}

	      //this is a much tighter cut, if we don't want any hit from any PFParticle or cosmic to cross with the showers 
	      /*
	      if(fCheckTrackOverlap)
		{
		  if(this->CheckTrackOverlap(pfParticleList, particle, longestTrack, pfParticleToClusterMap,clustersToHits))
                    {
                      e.put( std::move(pizeroroiVector) );
                      e.put( std::move(ROI_PFP_Assn) );

                      return false;
                    }
		}

	      if(fCheckOverlapAllPFParticles)
		{
		  if(this->CheckOverlapAllPFParticles(pfParticleList, particle, pfParticleToClusterMap,clustersToHits))
		    {
		      e.put( std::move(pizeroroiVector) );
		      e.put( std::move(ROI_PFP_Assn) );

		      return false;
		    }
		}

	      if(fCheckCosmicOverlap)
		{
		  if(this->CheckCosmicOverlap(pfParticleList, pfParticleListCosmic, particle, pfParticleToClusterMap, pfParticleToClusterMapCosmic,clustersToHits, clustersToHitsCosmic))
		    {
		      e.put( std::move(pizeroroiVector) );
		      e.put( std::move(ROI_PFP_Assn) );

		      return false;
		    }
		}
	      */
	      if (!this->BuildROI(particle, pfParticleList, longestTrack, showerIDsFinal, pfParticleToClusterMap, pfParticlesToVerticesMap, Vertex, MuonVertex,TrackEnd,WirePairs,TimePairs,PiZeroWirePairs,PiZeroTimePairs))
		{
		  e.put( std::move(pizeroroiVector) );
		  e.put( std::move(ROI_PFP_Assn) );

		  return false;
		}
	      
	      //store the ROI found
	      ana::PiZeroROI pizeroroi;
	      pizeroroi.SetVertex( Vertex );
	      pizeroroi.SetTrackEnd( TrackEnd );
	      pizeroroi.SetROI( WirePairs, TimePairs );
	      pizeroroi.SetPiZeroROI(PiZeroWirePairs,PiZeroTimePairs);
	      pizeroroi.SetCCIncVertex(CCIncVertex);
	      pizeroroi.SetMuonVertex(MuonVertex);
	      pizeroroi.SetNeutrinoVertex(NeutrinoVertex);
	      pizeroroiVector->emplace_back(pizeroroi);
	      
	      if (!util::CreateAssn(*this, e, *pizeroroiVector, particle, *ROI_PFP_Assn))
		{
		  throw art::Exception(art::errors::InsertFailure)
		    << "Can't associate";
		}
	      
	      pass = true;
	    }//if there is one vertex
	}//
    }//vertex ok        
  
  e.put( std::move(pizeroroiVector) );
  e.put( std::move(ROI_PFP_Assn) );
  
  return pass;
    }//end filter 
  
//------------------------------------------------------------------------------------------------------------------------------------------

const bool PiZeroFilter::CheckCosmicOverlap(lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticleVector pfParticleListCosmic, const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::PFParticlesToClusters pfParticleToClusterMapCosmic, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHitsCosmic) const
{
  //first get shower clusters
  const std::vector<size_t> &daughterIDs = particle->Daughters();
  for (size_t j = 0; j < daughterIDs.size(); ++j) // loop over neutrino daughters  
    {
      const art::Ptr<recob::PFParticle> daughter(pfParticleList.at(daughterIDs[j]));
      if(lar_pandora::LArPandoraHelper::IsShower(daughter)) // loop over showers  
        {
	  lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(daughter);//find clusters 
          if (clusterMapIter != pfParticleToClusterMap.end())
	    {
	      
	      lar_pandora::ClusterVector showerClusters = clusterMapIter->second;
	      
              if(showerClusters.size()>3)
		std::cerr << "Shower has more than three clusters!" << std::endl;
	      
              //check there are no more than one cluster in each plane                                                                          
              for(unsigned int k = 0; k<3; k++)
                {
                  int n_clusters = 0;
                  for(unsigned int l = 0; l < showerClusters.size(); ++l)
                    {
                      if(showerClusters[l]->Plane().Plane==k)
                        n_clusters++;
                    }
                  if(n_clusters>1)
		    std::cerr << "Shower has more than one cluster in one plane!" << std::endl;
                }
	      
	      for(unsigned int m = 0; m < showerClusters.size(); ++m)
                {
                  auto c_jdx = showerClusters[m]->Plane().Plane;
                  
		  //now loop over list of cosmics
		  for (unsigned int n = 0; n < pfParticleListCosmic.size(); ++n)
		    {
		      const art::Ptr<recob::PFParticle> cosmic = pfParticleListCosmic.at(n);

		      lar_pandora::PFParticlesToClusters::const_iterator cosmicMapIter = pfParticleToClusterMapCosmic.find(cosmic);
		      if (cosmicMapIter != pfParticleToClusterMapCosmic.end())
			{

			  lar_pandora::ClusterVector cosmicClusters = cosmicMapIter->second;

			  if(cosmicClusters.size()>3)
			    std::cerr << "Cosmic has more than three clusters!" << std::endl;

			  //check there are no more than one cluster in each plane                                                       
			  for(unsigned int p = 0; p<3; p++)
			    {
			      int n_clusters = 0;
			      for(unsigned int q = 0; q < cosmicClusters.size(); ++q)
				{
				  if(cosmicClusters[q]->Plane().Plane==p)
				    n_clusters++;
				}
			      if(n_clusters>1)
				std::cerr << "Cosmic has more than one cluster in one plane!" << std::endl;
			    }

			  for(unsigned int r = 0; r < cosmicClusters.size(); ++r)
			    {
			      auto c_idx = cosmicClusters[r]->Plane().Plane;
			      if(c_idx==c_jdx)
				{
				  if(this->UseCosmicCluster(cosmicClusters[r],clustersToHits, clustersToHitsCosmic))
				    {
				      if(this->CheckOverlap(cosmicClusters[r], showerClusters[m], clustersToHitsCosmic, clustersToHits))
					return true;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

  return false; 
}

//------------------------------------------------------------------------------------------------------------------------------------------

const bool PiZeroFilter::CheckTrackOverlap(lar_pandora::PFParticleVector pfParticleList, const art::Ptr<recob::PFParticle> particle, const art::Ptr<recob::PFParticle> track, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::ClustersToHits clustersToHits) const
{
  //first get shower clusters
  const std::vector<size_t> &daughterIDs = particle->Daughters();
  for (size_t j = 0; j < daughterIDs.size(); ++j) // loop over neutrino daughters  
    {
      const art::Ptr<recob::PFParticle> daughter(pfParticleList.at(daughterIDs[j]));
      if(lar_pandora::LArPandoraHelper::IsShower(daughter)) // loop over showers  
        {
	  lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(daughter);//find clusters 
          if (clusterMapIter != pfParticleToClusterMap.end())
	    {
	      
	      lar_pandora::ClusterVector showerClusters = clusterMapIter->second;
	      
              if(showerClusters.size()>3)
		std::cerr << "Shower has more than three clusters!" << std::endl;
	      
              //check there are no more than one cluster in each plane                                                                          
              for(unsigned int k = 0; k<3; k++)
                {
                  int n_clusters = 0;
                  for(unsigned int l = 0; l < showerClusters.size(); ++l)
                    {
                      if(showerClusters[l]->Plane().Plane==k)
                        n_clusters++;
                    }
                  if(n_clusters>1)
		    std::cerr << "Shower has more than one cluster in one plane!" << std::endl;
                }
	      
	      for(unsigned int m = 0; m < showerClusters.size(); ++m)
                {
                  auto c_jdx = showerClusters[m]->Plane().Plane;
                  
		  //now loop over the rest of PFParticles
		  lar_pandora::PFParticlesToClusters::const_iterator trackMapIter = pfParticleToClusterMap.find(track);
		  if (trackMapIter != pfParticleToClusterMap.end())
		    {
		      lar_pandora::ClusterVector trackClusters = trackMapIter->second;
		      
		      if(trackClusters.size()>3)
			std::cerr << "Track has more than three clusters!" << std::endl;
		      
		      //check there are no more than one cluster in each plane                                                       
		      for(unsigned int p = 0; p<3; p++)
			{
			  int n_clusters = 0;
			  for(unsigned int q = 0; q < trackClusters.size(); ++q)
			    {
			      if(trackClusters[q]->Plane().Plane==p)
				n_clusters++;
			    }
			  if(n_clusters>1)
			    std::cerr << "Track has more than one cluster in one plane!" << std::endl;
			}
		      
		      for(unsigned int r = 0; r < trackClusters.size(); ++r)
			{
			  auto c_idx = trackClusters[r]->Plane().Plane;
			  if(c_idx==c_jdx)
			    {
			      if(this->CheckOverlap(trackClusters[r], showerClusters[m], clustersToHits, clustersToHits))
				return true;
			    }
			}
		    }
		}
	    }
	}
    }     
  return false; 
}


//------------------------------------------------------------------------------------------------------------------------------------------

const bool PiZeroFilter::CheckOverlapAllPFParticles(lar_pandora::PFParticleVector pfParticleList, const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::ClustersToHits clustersToHits) const
{
  //first get shower clusters
  const std::vector<size_t> &daughterIDs = particle->Daughters();
  for (size_t j = 0; j < daughterIDs.size(); ++j) // loop over neutrino daughters  
    {
      const art::Ptr<recob::PFParticle> daughter(pfParticleList.at(daughterIDs[j]));
      if(lar_pandora::LArPandoraHelper::IsShower(daughter)) // loop over showers  
        {
	  lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(daughter);//find clusters 
          if (clusterMapIter != pfParticleToClusterMap.end())
	    {
	      
	      lar_pandora::ClusterVector showerClusters = clusterMapIter->second;
	      
              if(showerClusters.size()>3)
		std::cerr << "Shower has more than three clusters!" << std::endl;
	      
              //check there are no more than one cluster in each plane                                                                          
              for(unsigned int k = 0; k<3; k++)
                {
                  int n_clusters = 0;
                  for(unsigned int l = 0; l < showerClusters.size(); ++l)
                    {
                      if(showerClusters[l]->Plane().Plane==k)
                        n_clusters++;
                    }
                  if(n_clusters>1)
		    std::cerr << "Shower has more than one cluster in one plane!" << std::endl;
                }
	      
	      for(unsigned int m = 0; m < showerClusters.size(); ++m)
                {
                  auto c_jdx = showerClusters[m]->Plane().Plane;
                  
		  //now loop over the rest of PFParticles
		  for (unsigned int n = 0; n < pfParticleList.size(); ++n)
		    {
		      if(n == daughterIDs[j]) 
			continue;

		      const art::Ptr<recob::PFParticle> pfp = pfParticleList.at(n);
		      
		      lar_pandora::PFParticlesToClusters::const_iterator pfpMapIter = pfParticleToClusterMap.find(pfp);
		      if (pfpMapIter != pfParticleToClusterMap.end())
			{

			  lar_pandora::ClusterVector pfpClusters = pfpMapIter->second;

			  if(pfpClusters.size()>3)
			    std::cerr << "PFP has more than three clusters!" << std::endl;

			  //check there are no more than one cluster in each plane                                                       
			  for(unsigned int p = 0; p<3; p++)
			    {
			      int n_clusters = 0;
			      for(unsigned int q = 0; q < pfpClusters.size(); ++q)
				{
				  if(pfpClusters[q]->Plane().Plane==p)
				    n_clusters++;
				}
			      if(n_clusters>1)
				std::cerr << "PFP has more than one cluster in one plane!" << std::endl;
			    }

			  for(unsigned int r = 0; r < pfpClusters.size(); ++r)
			    {
			      auto c_idx = pfpClusters[r]->Plane().Plane;
			      if(c_idx==c_jdx)
				{
				  if(this->CheckOverlap(pfpClusters[r], showerClusters[m], clustersToHits, clustersToHits))
				    return true;
				}
			    }
			}
		    }
		}
	    }
	}
    }
  
  return false; 
}

//------------------------------------------------------------------------------------------------------------------------------------------

const bool PiZeroFilter::IsShortTrack(const art::Ptr<recob::PFParticle> track,lar_pandora::PFParticlesToTracks pfParticleToTrackMap)
{
  
  lar_pandora::PFParticlesToTracks::const_iterator trackMapIter = pfParticleToTrackMap.find(track);
  if (trackMapIter != pfParticleToTrackMap.end()) 
    {
      const lar_pandora::TrackVector &trackV = trackMapIter->second;
      
      if (trackV.size() > 1)
	std::cerr << "Warning: there was more than one track found " << std::endl;
      
      if (trackV.size() > 0)
	{
	  art::Ptr<recob::Track> theTrack = trackV.front();
	  
	  const float trkl = (theTrack->Vertex()-theTrack->End()).Mag();
	  
	  if(trkl<fShortTrackLengthCut)
	    return true;
	}
    }

  return false;

}

//------------------------------------------------------------------------------------------------------------------------------------------

const bool PiZeroFilter::CheckShowerLength(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToClusters pfParticleToClusterMap)
{
  const detinfo::DetectorProperties* detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();
  bool use_shower = false;

  lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(particle);//find clusters       
  if (clusterMapIter != pfParticleToClusterMap.end())
    {
      lar_pandora::ClusterVector showerClusters = clusterMapIter->second;
      
      for(unsigned int i = 0; i < showerClusters.size(); ++i)
	{
	  double wire_pitch   = 0.3;//geom->WirePitch(0,0,0,0); //wire pitch in cm                                            
	  double length = sqrt(pow((showerClusters[i]->StartWire()-showerClusters[i]->EndWire())*wire_pitch,2)+pow(detprop->ConvertTicksToX(showerClusters[i]->StartTick(),showerClusters[i]->View(),0,0)-detprop->ConvertTicksToX(showerClusters[i]->EndTick(),showerClusters[i]->View(),0,0),2));
	  
	  if(length>fShowerLengthCut) //use shower if it is long enough in at least one view (less conservative) 
	    use_shower = true;
	}
    }

  return use_shower;
}

//------------------------------------------------------------------------------------------------------------------------------------------                 
const bool PiZeroFilter::IsDetachedFromVertex(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToTracks pfParticleToTrackMap, art::Ptr<recob::Vertex> nuVertex, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap)
{
  double xyz_particle[3] = {0.,0.,0.};
  double xyz_neutrino[3] = {0.,0.,0.};
  lar_pandora::PFParticlesToVertices::const_iterator particleVertexMapIter = pfParticlesToVerticesMap.find(particle);
  
  if (particleVertexMapIter == pfParticlesToVerticesMap.end())
    std::cerr << "Warning: No vertex found" << std::endl;
  
  lar_pandora::VertexVector particleVertices = particleVertexMapIter->second;
  if (particleVertices.size() > 1)
    std::cerr << "Warning: more than one vertex found for the particle" << std::endl;
  
  art::Ptr<recob::Vertex> particleVertex = particleVertices.front();
  particleVertex->XYZ(xyz_particle);

  nuVertex->XYZ(xyz_neutrino);
  TVector3 nuVtx(xyz_neutrino[0],xyz_neutrino[1],xyz_neutrino[2]);

  float dist = std::sqrt(pow(xyz_particle[0]-xyz_neutrino[0],2)+pow(xyz_particle[1]-xyz_neutrino[1],2)+pow(xyz_particle[2]-xyz_neutrino[2],2));

  if(lar_pandora::LArPandoraHelper::IsTrack(particle))
    {
      lar_pandora::PFParticlesToTracks::const_iterator trackMapIter = pfParticleToTrackMap.find(particle);
      if (trackMapIter != pfParticleToTrackMap.end())
	{
	  const lar_pandora::TrackVector &theTracks = trackMapIter->second;

	  if (theTracks.size() > 1)
	    std::cerr << "Warning: there was more than one track found " << std::endl;

	  if (theTracks.size() > 0)
	    {
	      art::Ptr<recob::Track> theTrack = theTracks.front();
	      const float dist1 = (nuVtx-theTrack->Vertex()).Mag();
	      const float dist2 = (nuVtx-theTrack->End()).Mag();
      
	      if((dist1>fProximityCutToVertex) && (dist2>fProximityCutToVertex))
		return true;
	    }
	}
    }
  else
    {
      if(dist>fProximityCutToVertex)
	return true;
    }
  
  return false;
}
//------------------------------------------------------------------------------------------------------------------------------------------
const bool PiZeroFilter::IsCloseTrack(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticlesToTracks pfParticleToTrackMap, art::Ptr<recob::Vertex> nuVertex)
{
  double xyz_p[3] = {0.0, 0.0, 0.0} ;
  nuVertex->XYZ(xyz_p);//vertex of the neutrino primary particle in XYZ form                                                                                
  TVector3 nuVtx(xyz_p[0],xyz_p[1],xyz_p[2]);

  lar_pandora::PFParticlesToTracks::const_iterator trackMapIter = pfParticleToTrackMap.find(particle);
  if (trackMapIter != pfParticleToTrackMap.end())
    {
      const lar_pandora::TrackVector &theTracks = trackMapIter->second;

      if (theTracks.size() > 1)
	std::cerr << "Warning: there was more than one track found " << std::endl;

      if (theTracks.size() > 0)
	{
	  art::Ptr<recob::Track> theTrack = theTracks.front();
	  const float dist1 = (nuVtx-theTrack->Vertex()).Mag();
	  const float dist2 = (nuVtx-theTrack->End()).Mag();

	  if(dist1<fTrackVertexProximityCut || dist2<fTrackVertexProximityCut)
	    return true;
	}
    }
  return false;
}

//------------------------------------------------------------------------------------------------------------------------------------------
//now this is looking at potential-shower objects, either showers or short-tracks
const bool PiZeroFilter::NeutrinoHasAtLeastTwoShowerObjects(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticlesToTracks pfParticleToTrackMap, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, std::vector<size_t>& showerIDs, art::Ptr<recob::Vertex> nuVertex, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap)
{
  unsigned int n_showers = 0;
  const std::vector<size_t> &daughterIDs = particle->Daughters();

  for (size_t j = 0; j < daughterIDs.size(); ++j)
    {
      const art::Ptr<recob::PFParticle> daughter(pfParticleList.at(daughterIDs[j]));

      if (lar_pandora::LArPandoraHelper::IsShower(daughter)) 
	{
	  n_showers++;
	  if((this->CheckShowerLength(daughter,pfParticleToClusterMap)) && (this->IsDetachedFromVertex(daughter,pfParticleToTrackMap, nuVertex,pfParticlesToVerticesMap)))
	    showerIDs.push_back(daughterIDs[j]);
	}
      else
	{
	  if((this->IsShortTrack(daughter,pfParticleToTrackMap))&& (this->IsCloseTrack(particle, pfParticleToTrackMap, nuVertex)))
	    {
	      if((this->CheckShowerLength(daughter,pfParticleToClusterMap)) && (this->IsDetachedFromVertex(daughter,pfParticleToTrackMap, nuVertex,pfParticlesToVerticesMap)))
		showerIDs.push_back(daughterIDs[j]);
	    }
	}
    }

  fnShw = n_showers;
  return (showerIDs.size()>=2); 
}

//------------------------------------------------------------------------------------------------------------------------------------------

const int PiZeroFilter::GetNCloseCosmics(art::Ptr<recob::Vertex> nuVertex, lar_pandora::PFParticleVector pfParticleListCosmic, lar_pandora::PFParticlesToTracks pfParticleToTrackMapCosmic) const
{ 
  int close_cosmics = 0;
  double xyz_p[3] = {0.0, 0.0, 0.0} ;
  nuVertex->XYZ(xyz_p);//vertex of the neutrino primary particle in XYZ form                                                                       
  TVector3 nuVtx(xyz_p[0],xyz_p[1],xyz_p[2]);

  for (unsigned int n = 0; n < pfParticleListCosmic.size(); ++n)
    {
      const art::Ptr<recob::PFParticle> cosmic = pfParticleListCosmic.at(n);
      
      lar_pandora::PFParticlesToTracks::const_iterator trackMapIter = pfParticleToTrackMapCosmic.find(cosmic);
      if (trackMapIter != pfParticleToTrackMapCosmic.end()) 
	    {
	      const lar_pandora::TrackVector &cosmicTracks = trackMapIter->second;
	      
	      if (cosmicTracks.size() > 1)
		std::cerr << "Warning: there was more than one track found for cosmic " << std::endl;
	      
	      if (cosmicTracks.size() > 0)
		{
		  art::Ptr<recob::Track> cosmicTrack = cosmicTracks.front();
		  const float dist = (nuVtx-cosmicTrack->Vertex()).Mag();
		  const float dist2 = (nuVtx-cosmicTrack->End()).Mag();
		  
		  if(dist<fCosmicTrackVertexProximityCut || dist2<fCosmicTrackVertexProximityCut)
		    ++close_cosmics;

		}
	    }
    }

  return close_cosmics;
}

//------------------------------------------------------------------------------------------------------------------------------------------

const int PiZeroFilter::GetNCloseTracks(const art::Ptr<recob::PFParticle> particle, art::Ptr<recob::Vertex> nuVertex, lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticlesToTracks pfParticleToTrackMap) const
{ 
  int close_tracks = 0;
  double xyz_p[3] = {0.0, 0.0, 0.0} ;
  nuVertex->XYZ(xyz_p);//vertex of the neutrino primary particle in XYZ form
  TVector3 nuVtx(xyz_p[0],xyz_p[1],xyz_p[2]);
  
  for (unsigned int n = 0; n < pfParticleList.size(); ++n)
    {
      const art::Ptr<recob::PFParticle> daughter(pfParticleList.at(n));
      if(lar_pandora::LArPandoraHelper::IsTrack(daughter))
	{
	  lar_pandora::PFParticlesToTracks::const_iterator trackMapIter = pfParticleToTrackMap.find(daughter);
	  if (trackMapIter != pfParticleToTrackMap.end()) 
	    {
	      const lar_pandora::TrackVector &pfParticleTracks = trackMapIter->second;
	      
	      if (pfParticleTracks.size() > 1)
		std::cerr << "Warning: there was more than one track found for daughter particle with ID " << std::endl;
	      
	      if (pfParticleTracks.size() > 0)
		{
		  art::Ptr<recob::Track> daughterTrack = pfParticleTracks.front();
		  const float dist = (nuVtx-daughterTrack->Vertex()).Mag();
		  const float dist2 = (nuVtx-daughterTrack->End()).Mag();
		  
		  if(dist<fTrackVertexProximityCut || dist2<fTrackVertexProximityCut)
		    ++close_tracks;
		}
	    }
	}
    }
  
  return close_tracks;
}

//-----------------------------------------------------------------------------------------------------------------------------------------
const bool PiZeroFilter::DetachedSegments(float p1x, float p2x, float p1y, float p2y, float q1x, float q2x,float q1y, float q2y) const
{
  //do cross products of vectors of the two segments
  double cross_prod_0 = (p2x-p1x)*(q2y-q1y)-(p2y-p1y)*(q2x-q1x);
  double cross_prod_1 = (p2x-p1x)*(p1y-q1y)-(p2y-p1y)*(p1x-q1x);
  double cross_prod_2 = (q2x-q1x)*(p1y-q1y)-(q2y-q1y)*(p1x-q1x);

  //case 1: collinear
  if(cross_prod_0 == 0) //parallel
    { 
      if(cross_prod_1 == 0) //collinear
	{
	  if( ((q1x <= std::max(p1x, p2x) && q1x >= std::min(p1x, p2x) && (q1y <= std::max(p1y, p2y) && q1y >= std::min(p1y, p2y)))) &&
	      ((q2x <= std::max(p1x, p2x) && q2x >= std::min(p1x, p2x) && (q2y <= std::max(p1y, p2y) && q2y >= std::min(p1y, p2y)))))
	    return false;
	  //otherwise collinear but disjoint
	  else
	    return true;
	}
      //case 2: parallel but not intersecting
      else
	return true;
    }
  //case 3: calculate intersection points
  else
    {
      double u = cross_prod_1/cross_prod_0;
      double t = cross_prod_2/cross_prod_0;
      if((t>=0)&&(t<=1)&&(u>=0)&&(u<=1))
	return false;

      //case 4: not parallel, not intersecting
      else
	return true;
    }
}

//-----------------------------------------------------------------------------------------------------------------------------------------
const bool PiZeroFilter::IsDetached(art::Ptr<recob::PFParticle> track, art::Ptr<recob::PFParticle> shower, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap) const
{
  //first, get vertex of the track
  double xyz_track[3] = {0.,0.,0.};
  lar_pandora::PFParticlesToVertices::const_iterator trackVertexMapIter = pfParticlesToVerticesMap.find(track);
  
  if (trackVertexMapIter == pfParticlesToVerticesMap.end())
    std::cerr << "Warning: No vertex found for the longest track!" << std::endl;
  
  lar_pandora::VertexVector trackVertices = trackVertexMapIter->second;
  if (trackVertices.size() > 1)
    std::cerr << "Warning: more than one vertex found for the longest track!" << std::endl;
  
  art::Ptr<recob::Vertex> trackVertex = trackVertices.front();
  trackVertex->XYZ(xyz_track);
  
  //then, vertex of the shower
  lar_pandora::PFParticlesToVertices::const_iterator vertexMapIter = pfParticlesToVerticesMap.find(shower);
  
  if (vertexMapIter != pfParticlesToVerticesMap.end())
    { //get vertex                                                                                                                    
      lar_pandora::VertexVector showerVertices = vertexMapIter->second;
      if (showerVertices.size() > 1)
	return false;
      art::Ptr<recob::Vertex> showerVertex = showerVertices.front();
      double xyz_shower[3] = {0.,0.,0.};
      showerVertex->XYZ(xyz_shower);
      
      float dist = std::sqrt(pow(xyz_track[0]-xyz_shower[0],2)+pow(xyz_track[1]-xyz_shower[1],2)+pow(xyz_track[2]-xyz_shower[2],2));
      
      if(dist<fShowerVertex2dProximityCut)
	return true;
    }
  
  return false;
}

//------------------------------------  

const bool PiZeroFilter::CheckOverlap(art::Ptr<recob::Cluster> trackCluster, art::Ptr<recob::Cluster> showerCluster, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHits2 ) const
{
  std::map< geo::WireID, std::pair<double,double>> tick_range_perWire;
  //  art::ServiceHandle<geo::Geometry> theGeometry;
  
  //loop over hits in the shower cluster to store min and max ticks per wire ID 
  lar_pandora::ClustersToHits::const_iterator showerClustersHitsMapIter = clustersToHits2.find(showerCluster);
  if(showerClustersHitsMapIter != clustersToHits2.end()){
    const lar_pandora::HitVector hits = showerClustersHitsMapIter->second;
  
    for(unsigned int i = 0; i < hits.size(); i++)
      {
	const art::Ptr<recob::Hit> hit(hits[i]);
	const double hit_Time(hit->PeakTime());
	const geo::WireID wire(hit->WireID());
	
	std::map<geo::WireID, std::pair<double,double>>::iterator iter = tick_range_perWire.find(wire);
	
	if (iter == tick_range_perWire.end())
	  {
	    std::pair<double,double> range = std::make_pair(hit_Time, hit_Time);
	    tick_range_perWire[wire] = range;
	  }
	else
	  {
	    if(hit_Time > iter->second.second)
	      iter->second.second = hit_Time;
	    if(hit_Time < iter->second.first)
	      iter->second.first = hit_Time;
	  }
      }
  }
  

  //loop over hits in the track cluster
  lar_pandora::ClustersToHits::const_iterator trackClustersHitsMapIter = clustersToHits.find(trackCluster);
  if(trackClustersHitsMapIter != clustersToHits.end())
    {
      const lar_pandora::HitVector hits = trackClustersHitsMapIter->second;
        for(unsigned int i = 0; i < hits.size(); i++)
	{
	  const art::Ptr<recob::Hit> hit(hits[i]);
	  double time = hit->PeakTime();
	  geo::WireID wire = hit->WireID();
	  std::map<geo::WireID, std::pair<double,double>>::iterator iter = tick_range_perWire.find(wire);
	  
	  if (iter != tick_range_perWire.end())
	    {
	      if((time<=iter->second.second) &&
		 (time>=iter->second.first))
		{
		  return true;
		}
	      
	      else	
		return false;
	      
	    }
	  
	}
	
    }
    
  return false;
}


//---------------------------------------------------------------------------------------------------------------------------------------------------------  
const int PiZeroFilter::NDetachedClusters(art::Ptr<recob::PFParticle> particle, art::Ptr<recob::PFParticle> track, art::Ptr<recob::PFParticle> shower, lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticleVector pfParticleListCosmic, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::PFParticlesToClusters pfParticleToClusterMapCosmic, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHitsCosmic) const
{
  const detinfo::DetectorProperties* detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();

  int detachedclusters = 0;

  lar_pandora::PFParticlesToClusters::const_iterator showerClusterMapIter = pfParticleToClusterMap.find(shower);
  if (showerClusterMapIter != pfParticleToClusterMap.end()) 
    {
      lar_pandora::ClusterVector showerClusters = showerClusterMapIter->second;
      
      if(showerClusters.size()>3)
	std::cerr << "Shower has more than three clusters!" << std::endl;
      
      //check there are no more than one cluster in each plane                                                                 
      for(unsigned int k = 0; k<3; k++)
	{
	  int n_clusters = 0;
	  for(unsigned int l = 0; l < showerClusters.size(); ++l)
	    {
	      if(showerClusters[l]->Plane().Plane==k)
		n_clusters++;
	    }
	  if(n_clusters>1)
	    std::cerr << "Shower has more than one cluster in one plane!" << std::endl;
	}
      
      for(unsigned int j = 0; j < showerClusters.size(); ++j)
	{
	  bool detached = true;
	  auto c_jdx = showerClusters[j]->Plane().Plane;

	  //loop over the list of PFParticles after the neutrino pass
	  for (unsigned int n = 0; n < pfParticleList.size(); ++n)
	    {
	      const art::Ptr<recob::PFParticle> pfp = pfParticleList.at(n);
	      if(lar_pandora::LArPandoraHelper::IsNeutrino(pfp))
		 continue;
	      
	      if(pfp->Self()==shower->Self())
		continue;

	      if(!fCheckDetachmentToOtherShowers)
		{
		  //skip if shower daughter of the neutrino - we want to have 2 showers, might be close
		  bool other_daughter_shower = false;
		  const std::vector<size_t> &daughterIDs = particle->Daughters();
		  for (size_t j = 0; j < daughterIDs.size(); ++j) // loop over neutrino daughters                                                          
		    {
		      const art::Ptr<recob::PFParticle> daughter(pfParticleList.at(daughterIDs[j]));
		      if(lar_pandora::LArPandoraHelper::IsShower(daughter))
			{
			  if(pfp->Self()==daughter->Self())
			    other_daughter_shower = true;
			}
		    }
		  if(other_daughter_shower)
		    continue;
		}

	      //if arrived here, should check clusters distance
	      lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(pfp);
	      if (clusterMapIter != pfParticleToClusterMap.end())
		{
		  lar_pandora::ClusterVector pfpClusters = clusterMapIter->second;

		  if(pfpClusters.size()>3)
		    std::cerr << "PFP has more than three clusters!" << std::endl;

		  //check there are no more than one cluster in each plane                                                                             
		  for(unsigned int k = 0; k<3; k++)
		    {
		      int n_clusters = 0;
		      for(unsigned int l = 0; l < pfpClusters.size(); ++l)
			{
			  if(pfpClusters[l]->Plane().Plane==k)
			    n_clusters++;
			}
		      if(n_clusters>1)
			std::cerr << "PFP has more than one cluster in one plane!" << std::endl;
		    }

		  for(unsigned int i = 0; i < pfpClusters.size(); ++i)
		    {
		      auto c_idx = pfpClusters[i]->Plane().Plane;
		      if(c_idx==c_jdx)
			{
			  //one - check if clusters are crossing
			  if(!this->DetachedSegments(detprop->ConvertTicksToX(pfpClusters[i]->StartTick(),pfpClusters[i]->View(),0,0),detprop->ConvertTicksToX(pfpClusters[i]->EndTick(),pfpClusters[i]->View(),0,0),pfpClusters[i]->StartWire(), pfpClusters[i]->EndWire(),detprop->ConvertTicksToX(showerClusters[j]->StartTick(), showerClusters[j]->View(),0,0), detprop->ConvertTicksToX(showerClusters[j]->EndTick(),showerClusters[j]->View(),0, 0),showerClusters[j]->StartWire(),showerClusters[j]->EndWire()))
			    detached = false;
			  
			  //two - check distance
			  float distance = this->GetClosestDistance(showerClusters[j],pfpClusters[i]);
			  if(distance<fMinDistanceAnyCluster)
			    detached = false;
			}
		    }
		}
	    } // end of loop over pfparticles from pandora nu
	  

	  //now check the same shower cluster with any other remaining clusters from cosmic pass
	  for (unsigned int n = 0; n < pfParticleListCosmic.size(); ++n)
            {
              const art::Ptr<recob::PFParticle> cosmic = pfParticleListCosmic.at(n);
	      
	      lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMapCosmic.find(cosmic);
	      if (clusterMapIter != pfParticleToClusterMapCosmic.end())
		{
		  lar_pandora::ClusterVector cosmicClusters = clusterMapIter->second;

		  if(cosmicClusters.size()>3)
		    std::cerr << "Cosmic has more than three clusters!" << std::endl;

		  //check there are no more than one cluster in each plane                                                                             
		  for(unsigned int k = 0; k<3; k++)
		    {
		      int n_clusters = 0;
		      for(unsigned int l = 0; l < cosmicClusters.size(); ++l)
			{
			  if(cosmicClusters[l]->Plane().Plane==k)
			    n_clusters++;
			}
		      if(n_clusters>1)
			std::cerr << "Cosmic has more than one cluster in one plane!" << std::endl;
		    }
		  
		  for(unsigned int i = 0; i < cosmicClusters.size(); ++i)
		    {
		      auto c_idx = cosmicClusters[i]->Plane().Plane;
		      if(c_idx==c_jdx)
			{
			  if(this->UseCosmicCluster(cosmicClusters[i],clustersToHits, clustersToHitsCosmic))
			    {
			      //one - check if clusters crossing
			      if(!this->DetachedSegments(detprop->ConvertTicksToX(cosmicClusters[i]->StartTick(),cosmicClusters[i]->View(),0,0),detprop->ConvertTicksToX(cosmicClusters[i]->EndTick(),cosmicClusters[i]->View(),0,0),cosmicClusters[i]->StartWire(), cosmicClusters[i]->EndWire(),detprop->ConvertTicksToX(showerClusters[j]->StartTick(), showerClusters[j]->View(),0,0), detprop->ConvertTicksToX(showerClusters[j]->EndTick(),showerClusters[j]->View(),0, 0),showerClusters[j]->StartWire(),showerClusters[j]->EndWire()))
				{
				  detached = false;
				}
			      
			      //second - check minimum distance
			      float distance = this->GetClosestDistance(showerClusters[j],cosmicClusters[i]);
			      if(distance<fMinDistanceAnyCluster)
				{
				  detached = false;
				}
			    }
			}
		    }
		}
	    } // end of loop over pfparticles from pandora cosmic

	  if (detached)
	    ++detachedclusters;
	  
	}//end of shower clusters loop
      
    }
  return detachedclusters;
  
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------  
const bool PiZeroFilter::UseCosmicCluster(art::Ptr<recob::Cluster> cosmicCluster, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHitsCosmic) const
{
  //loop over hits in cosmic cluster
  //compare to list of hits in clusterstohits - loop over all size
  lar_pandora::ClustersToHits::const_iterator cosmicClustersHitsMapIter = clustersToHitsCosmic.find(cosmicCluster);
  if(cosmicClustersHitsMapIter != clustersToHitsCosmic.end())
    {
      const lar_pandora::HitVector hitsCosmic = cosmicClustersHitsMapIter->second;
      
      for(unsigned int i = 0; i < hitsCosmic.size(); i++)
	{
	  const art::Ptr<recob::Hit> hitCosmic(hitsCosmic[i]);
	  const double hitTimeCosmic(hitCosmic->PeakTime());
	  const geo::WireID wireCosmic(hitCosmic->WireID());
	  
	  for(lar_pandora::ClustersToHits::const_iterator iter = clustersToHits.begin(); iter !=clustersToHits.end(); ++iter)
	  {
	    const lar_pandora::HitVector hits = iter->second;
	    for(unsigned int j = 0; j < hits.size(); j++)
	      {
		const art::Ptr<recob::Hit> hit(hits[j]);
		const double hitTime(hit->PeakTime());
		const geo::WireID wire(hit->WireID());
		
		if((hitTime==hitTimeCosmic)&&(wire==wireCosmic))
		  {
		    return false;
		  }
	      }
	  }
	}
    }
  return true;
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------  
const float PiZeroFilter::GetClosestDistance(art::Ptr<recob::Cluster> showerCluster, art::Ptr<recob::Cluster> cosmicCluster) const
{
  const detinfo::DetectorProperties* detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();
  art::ServiceHandle<geo::Geometry> theGeometry;
  double min_distance = 0;
  double wire_pitch   = 0.3;//geom->WirePitch(0,0,0,0); //wire pitch in cm                                                   

  //first calculate distance between end/start points from both clusters
  double dist1 = sqrt(pow((showerCluster->StartWire()-cosmicCluster->StartWire())*wire_pitch,2)+pow(detprop->ConvertTicksToX(showerCluster->StartTick(),showerCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->StartTick(),cosmicCluster->View(),0,0),2));

  double dist2 = sqrt(pow((showerCluster->StartWire()-cosmicCluster->EndWire())*wire_pitch,2)+pow(detprop->ConvertTicksToX(showerCluster->StartTick(),showerCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->EndTick(),cosmicCluster->View(),0,0),2));

  double dist3 = sqrt(pow((showerCluster->EndWire()-cosmicCluster->StartWire())*wire_pitch,2)+pow(detprop->ConvertTicksToX(showerCluster->EndTick(),showerCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->StartTick(),cosmicCluster->View(),0,0),2));

  double dist4 = sqrt(pow((showerCluster->EndWire()-cosmicCluster->EndWire())*wire_pitch,2)+pow(detprop->ConvertTicksToX(showerCluster->EndTick(),showerCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->EndTick(),cosmicCluster->View(),0,0),2));

  //second, calculate distance from point to line
  double line_length=sqrt(pow((cosmicCluster->StartWire()-cosmicCluster->EndWire())*wire_pitch,2)+pow(detprop->ConvertTicksToX(cosmicCluster->StartTick(),cosmicCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->EndTick(),cosmicCluster->View(),0,0),2));

  double dist5=std::abs((cosmicCluster->StartWire()-cosmicCluster->EndWire())*wire_pitch*(detprop->ConvertTicksToX(showerCluster->StartTick(),showerCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->StartTick(),cosmicCluster->View(),0,0)) - ((showerCluster->StartWire()-cosmicCluster->StartWire())*wire_pitch*(detprop->ConvertTicksToX(cosmicCluster->StartTick(),cosmicCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->EndTick(),cosmicCluster->View(),0,0))) )/line_length;

  double dist6 = std::abs((cosmicCluster->StartWire()-cosmicCluster->EndWire())*wire_pitch*(detprop->ConvertTicksToX(showerCluster->EndTick(),showerCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->StartTick(),cosmicCluster->View(),0,0)) - ((showerCluster->EndWire()-cosmicCluster->StartWire())*wire_pitch*(detprop->ConvertTicksToX(cosmicCluster->StartTick(),cosmicCluster->View(),0,0)-detprop->ConvertTicksToX(cosmicCluster->EndTick(),cosmicCluster->View(),0,0))) )/line_length;

  
  min_distance = std::min(dist1,std::min(dist2,std::min(dist3, std::min(dist4,std::min(dist5,dist6)))));

  return min_distance;
}


//------------------------------------------------------------------------------------------------------------------------------------------

bool PiZeroFilter::CheckShowerObjects(const art::Ptr<recob::PFParticle> particle, art::Ptr<recob::PFParticle> longestTrack, lar_pandora::PFParticleVector pfParticleList, lar_pandora::PFParticleVector pfParticleListCosmic, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::PFParticlesToClusters pfParticleToClusterMapCosmic, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap, lar_pandora::ClustersToHits clustersToHits, lar_pandora::ClustersToHits clustersToHitsCosmic, std::vector<size_t>& showerIDs, std::vector<size_t>& showerIDsFinal)
{

  const detinfo::DetectorProperties* detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();

  // find at least two long and detached showers
  int n_detached_showers = 0;
  int n_detached_showers_2views = 0;
  int n_detached_showers_3views = 0;

  for (size_t j = 0; j < showerIDs.size(); ++j) // loop over neutrino daughters                                                              
    {
      const art::Ptr<recob::PFParticle> shower(pfParticleList.at(showerIDs[j]));
      lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(shower);//find clusters       
      if (clusterMapIter != pfParticleToClusterMap.end())
	{
	  
	  if(fNotCheckDetachmentAtAll) //if no detachment to be checked at all (!) continue here
	    showerIDsFinal.push_back(showerIDs[j]);
	  else
	    {
	      //if shower is long enough, check detachment... 
	      bool detachment = false;
	      int detached_clusters = 0;
	      
	      if(fUseVerticesForDetachedCut){
		if(this->IsDetached(longestTrack,shower,pfParticlesToVerticesMap))
		  {
		    ++n_detached_showers;
		    detachment = true;
		  }
	      }
	      else
		{
		  detached_clusters = this->NDetachedClusters(particle,longestTrack,shower,pfParticleList, pfParticleListCosmic,pfParticleToClusterMap, pfParticleToClusterMapCosmic, clustersToHits, clustersToHitsCosmic);
		  
		  
		  if(detached_clusters>=2) 
		    {
		      detachment = true;
		      n_detached_showers_2views++;
		    }
		  if(detached_clusters>2)
		    n_detached_showers_3views++;
		  
		}
	      
	      //end - if detached after all tests, store
	      if(detachment)	  
		showerIDsFinal.push_back(showerIDs[j]);
	      
	    }
	}
    }
  
  if(showerIDsFinal.size()<2)
    return false;
  else if(!fNotCheckDetachmentAtAll)
    {
      if(fUseVerticesForDetachedCut && n_detached_showers<2)
	return false;
      else if((n_detached_showers_2views<fMinDetachedShowersIn2Views) || (n_detached_showers_3views<fMinDetachedShowersIn3Views))
	return false;
      else 
	return true;
    }
  else
    return true;
  
}

//------------------------------------------------------------------------------------------------------------------------------------------
bool PiZeroFilter::BuildROI(const art::Ptr<recob::PFParticle> particle, lar_pandora::PFParticleVector pfParticleList,art::Ptr<recob::PFParticle> longestTrack, std::vector<size_t> showerIDs, lar_pandora::PFParticlesToClusters pfParticleToClusterMap, lar_pandora::PFParticlesToVertices pfParticlesToVerticesMap, std::vector<std::pair<int,int> > & Vertex, std::vector<float> & MuonVertex, std::vector<std::pair<int,int> > & TrackEnd,  std::vector<std::pair<int,int> > & WirePairs, std::vector<std::pair<int,int> > & TimePairs, std::vector<std::pair<int,int> > & PiZeroWirePairs, std::vector<std::pair<int,int> > & PiZeroTimePairs) 
{
  std::vector<float>  startw  = std::vector<float>{8256.,8256.,8256.};
  std::vector<float>  startt = std::vector<float>{9600.,9600.,9600.};
  std::vector<float>  endw = std::vector<float>{0.,0.,0.};
  std::vector<float>  endt = std::vector<float>{0.,0.,0.};

  std::vector<float>  pi0startw  = std::vector<float>{8256.,8256.,8256.};
  std::vector<float>  pi0startt = std::vector<float>{9600.,9600.,9600.};
  std::vector<float>  pi0endw = std::vector<float>{0.,0.,0.};
  std::vector<float>  pi0endt = std::vector<float>{0.,0.,0.};

  
  // 1 - fill with longest track info
  lar_pandora::PFParticlesToVertices::const_iterator trackVertexMapIter = pfParticlesToVerticesMap.find(longestTrack);
  
  if (trackVertexMapIter == pfParticlesToVerticesMap.end())
    std::cerr << "Warning: No vertex found for the longest track!" << std::endl;
  
  lar_pandora::VertexVector trackVertices = trackVertexMapIter->second;
  if (trackVertices.size() > 1)
    std::cerr << "Warning: more than one vertex found for the longest track!" << std::endl;

  art::Ptr<recob::Vertex> trackVertex = trackVertices.front();
  double xyz_0[3] = {0.0, 0.0, 0.0} ;
  trackVertex->XYZ(xyz_0);
  MuonVertex[0]= xyz_0[0];
  MuonVertex[1]= xyz_0[1];
  MuonVertex[2]= xyz_0[2];
  
  lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(longestTrack); 
  if (clusterMapIter != pfParticleToClusterMap.end()) {
    lar_pandora::ClusterVector trackClusters = clusterMapIter->second;
    
    for(unsigned int i = 0; i < trackClusters.size(); ++i)
      {
	auto c_idx = trackClusters[i]->Plane().Plane;
	Vertex[c_idx] = std::make_pair(trackClusters[i]->StartTick(),trackClusters[i]->StartWire());

	TrackEnd[c_idx] = std::make_pair(trackClusters[i]->EndTick(),trackClusters[i]->EndWire());

	startw[c_idx] = std::min(startw[c_idx],std::min(trackClusters[i]->StartWire(),trackClusters[i]->EndWire()));
	endw[c_idx] = std::max(endw[c_idx],std::max(trackClusters[i]->StartWire(),trackClusters[i]->EndWire()));
	startt[c_idx] = std::min(startt[c_idx],std::min(trackClusters[i]->StartTick(),trackClusters[i]->EndTick()));
	endt[c_idx] = std::max(endt[c_idx],std::max(trackClusters[i]->StartTick(),trackClusters[i]->EndTick()));
      }
  }
  
  // 2 - detached showers
  for (size_t j = 0; j < showerIDs.size(); ++j) // loop over neutrino daughters                                                   
    {
      const art::Ptr<recob::PFParticle> daughter(pfParticleList.at(showerIDs[j]));

      lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(daughter);//find clusters 
      if (clusterMapIter != pfParticleToClusterMap.end())
	{
	  lar_pandora::ClusterVector showerClusters = clusterMapIter->second;
	  for(unsigned int i = 0; i < showerClusters.size(); ++i)
	    {
	      auto c_idx = showerClusters[i]->Plane().Plane;		      
	      
	      if((startt[c_idx]==std::min(showerClusters[i]->StartTick(),showerClusters[i]->EndTick())) &&
		 (startt[c_idx]==Vertex[c_idx].first)) //track and two showers starting at the same tick
		{
		  std::cout << "The two showers and track start at the same tick!" << std::endl;
		  return false;
		}
	      
	      startw[c_idx] = std::min(startw[c_idx],std::min(showerClusters[i]->StartWire(),showerClusters[i]->EndWire()));
	      endw[c_idx] = std::max(endw[c_idx],std::max(showerClusters[i]->StartWire(),showerClusters[i]->EndWire()));
	      startt[c_idx] = std::min(startt[c_idx],std::min(showerClusters[i]->StartTick(),showerClusters[i]->EndTick()));
	      endt[c_idx] = std::max(endt[c_idx],std::max(showerClusters[i]->StartTick(),showerClusters[i]->EndTick()));
	      pi0startw[c_idx] = std::min(pi0startw[c_idx],std::min(showerClusters[i]->StartWire(),showerClusters[i]->EndWire()));
	      pi0endw[c_idx] = std::max(pi0endw[c_idx],std::max(showerClusters[i]->StartWire(),showerClusters[i]->EndWire()));
	      pi0startt[c_idx] = std::min(pi0startt[c_idx],std::min(showerClusters[i]->StartTick(),showerClusters[i]->EndTick()));
	      pi0endt[c_idx] = std::max(pi0endt[c_idx],std::max(showerClusters[i]->StartTick(),showerClusters[i]->EndTick()));
	      
	    }
	}
    }
  
  for(int i = 0; i<3; ++i) {
    TimePairs[i] = std::make_pair(std::max(0.,double(-1*fPadding)+startt[i]),
				  std::min(9600.0,double(fPadding)+endt[i]));
    WirePairs[i] = std::make_pair(std::max(0.,double(-1*fPadding)+startw[i]),
				  std::min(8256.0,double(fPadding)+endw[i]));
    PiZeroTimePairs[i] = std::make_pair(std::max(0.,double(-1*fPadding)+pi0startt[i]),
					std::min(9600.0,double(fPadding)+pi0endt[i]));
    PiZeroWirePairs[i] = std::make_pair(std::max(0.,double(-1*fPadding)+pi0startw[i]),
					std::min(8256.0,double(fPadding)+pi0endw[i]));
    
  }
  
  return true;
}
  
//------------------------------------------------------------------------------------------------------------------------------------------

// reconfigure 
void PiZeroFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fPFPModuleLabel = p.get<std::string>("PFPModuleLabel");
  fPFPModuleLabelCosmic = p.get<std::string>("PFPModuleLabelCosmic");
  fVertexModuleLabel = p.get<std::string>("VertexModuleLabel");
  fClusterModuleLabel = p.get<std::string>("ClusterModuleLabel");
  fTrackModuleLabel = p.get<std::string>("TrackModuleLabel");
  fCCInclusiveModuleLabel = p.get<std::string>("CCInclusiveModuleLabel");

  // Implementation of optional member function here.
  fMuonTrackLengthCut = p.get<float>("MuonTrackLengthCut");
  fShortTrackLengthCut = p.get<float>("ShortTrackLengthCut");
  fShowerLengthCut = p.get<float>("ShowerLengthCut");
  fUseShowerLengthCut = p.get<bool>("UseShowerLengthCut");
  fProximityCutToVertex = p.get<float>("ProximityCutToVertex");
  fTrackVertexProximityCut = p.get<float>("TrackVertexProximityCut");
  fShowerVertex2dProximityCut = p.get<float>("ShowerVertex2dProximityCut");
  fShowerDetached2dProximityCut = p.get<float>("ShowerDetached2dProximityCut");
  fMinDistanceAnyCluster = p.get<float>("MinDistanceAnyCluster");

  fNotCheckDetachmentAtAll = p.get<bool>("NotCheckDetachmentAtAll");
  fUseVerticesForDetachedCut = p.get<bool>("UseVerticesForDetachedCut");
  fCheckTrackOverlap = p.get<bool>("CheckTrackOverlap");
  fCheckCosmicOverlap = p.get<bool>("CheckCosmicOverlap");
  fCheckOverlapAllPFParticles = p.get<bool>("CheckOverlapAllPFParticles");
  fCheckDetachmentToOtherShowers = p.get<bool>("CheckDetachmentToOtherShowers");
  fRejectMoreThanOneRecoNeutrino = p.get<bool>("RejectMoreThanOneRecoNeutrino");

  fMaxNeutrinoShowers = p.get<int>("MaxNeutrinoShowers");
  fMaxCloseTracks = p.get<int>("MaxCloseTracks");
  fMaxCosmicTracks = p.get<int>("MaxCosmicTracks");
  fMinDetachedShowersIn2Views = p.get<int>("MinDetachedShowersIn2Views");
  fMinDetachedShowersIn3Views = p.get<int>("MinDetachedShowersIn3Views");
  fPadding = p.get<float>("Padding");
}

DEFINE_ART_MODULE(PiZeroFilter)





	  



